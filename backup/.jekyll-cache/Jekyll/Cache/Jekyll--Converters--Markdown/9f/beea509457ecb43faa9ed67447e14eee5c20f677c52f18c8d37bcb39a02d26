I"X;<p>참고: doit 자료구조와 함께 배우는 알고리즘 입문</p>

<p>병합정렬(merge sort)은 배열을 앞부분과 뒷부분의 두 그룹으로 나누어 각각 정렬한 후 병합하는 작업을 반복하는 알고리즘입니다.</p>

<h3 id="정렬을-마친-배열의-병합">정렬을 마친 배열의 병합</h3>

<p>각 배열에서 주목하는 원소의 값을 비교하여 작은 쪽의 원소를 꺼내 새로운 배열에 저장합니다. 이 과정을 반복하며 정렬을 마친 배열을 만듭니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 정렬을 마친 두 배열을 병합하기
</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">MutableSequence</span>


<span class="k">def</span> <span class="nf">merge_sorted_list</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">MutableSequence</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="s">"""정렬을 마친 배열 a와 b를 병합하여 c에 저장"""</span>
    <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1"># 각 배열의 커서
</span>    <span class="n">na</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>     <span class="c1"># 각 배열의 원소 수
</span>
    <span class="k">while</span> <span class="n">pa</span> <span class="o">&lt;</span> <span class="n">na</span> <span class="ow">and</span> <span class="n">pb</span> <span class="o">&lt;</span> <span class="n">nb</span><span class="p">:</span>              <span class="c1"># pa와 pb를 비교하여 작은 값을 pc에 저장
</span>        <span class="c1"># print(f' {a[pa]} {b[pb]}')
</span>        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">pa</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="n">pb</span><span class="p">]:</span>
            <span class="n">c</span><span class="p">[</span><span class="n">pc</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">pa</span><span class="p">]</span>
            <span class="n">pa</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span><span class="p">[</span><span class="n">pc</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">pb</span><span class="p">]</span>
            <span class="n">pb</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># print(f'배열 c: {c}')
</span>
    <span class="k">while</span> <span class="n">pa</span> <span class="o">&lt;</span> <span class="n">na</span><span class="p">:</span>                          <span class="c1"># a에 남은 원소를 c에 복사
</span>        <span class="n">c</span><span class="p">[</span><span class="n">pc</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">pa</span><span class="p">]</span>
        <span class="n">pa</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">pb</span> <span class="o">&lt;</span> <span class="n">nb</span><span class="p">:</span>                          <span class="c1"># b에 남은 원소를 c에 복사
</span>        <span class="n">c</span><span class="p">[</span><span class="n">pc</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">pb</span><span class="p">]</span>
        <span class="n">pb</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># print(f'배열 c: {c}')
</span></code></pre></div></div>

<ul>
  <li>pa와 pb를 비교하여 작은 값을 pc에 대입하고 작은 값이 있던 커서와 pc를 +1해준다. 값을 꺼내지 않은 커서는 움직이지 않는다. 커서 pa와 pb가 배열의 끝에 도달하면 while 문이 종료된다.</li>
  <li>커서가 아직 끝에 도달하지 않은 경우 배열에 남은 원소를 모두 c에 복사한다. (a,b의 길이가 달라서 하나만 끝에 도달한 경우 실행됨)</li>
</ul>

<h4 id="sorted-함수로-병합-정렬하기">sorted() 함수로 병합 정렬하기</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>
    <p>a와 b를 연결하여 오름차운으로 정렬한 것을 list로 변환하여 c에 저장</p>
  </li>
  <li>
    <p>a와 b가 정렬을 마친 상태가 아니어도 적용할 수 있다는 장점이 있지만, 속도가 빠르지 않다는 단점도 있습니다. 빠르게 병합하려면 다음과 같이 heapq 모듈의 merge()함수를 사용하면 됩니다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 정렬을 마친 두 뱅려의 병합(heapq.merge 사용)
</span>  
<span class="kn">import</span> <span class="nn">heapq</span>
  
<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>        <span class="c1"># 배열 a와 b를 병합하여 c에 저장
</span>  
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="병합-정렬-만들기">병합 정렬 만들기</h3>

<p>정렬을 마친 배열의 병합을 응용하여 분할 정복법에 따라 정렬하는 알고리즘을 병합 정렬이라고 합니다.</p>

<p>주어진 배열을 두개의 배열로 나눈 후, 나눈 두 배열을 각각 정렬한 뒤 병합하여 배열 정렬을 완료합니다. 배열을 반으로 나눈 앞부분과 뒷부분의 정렬을 각각 수행할 때도 똑같이 병합 정렬을 적용하여 진행합니다.</p>

<h4 id="병합-정렬-알고리즘">병합 정렬 알고리즘</h4>

<p><strong>배열의 원소 수가 2개 이상인 경우</strong></p>

<ol>
  <li>배열의 앞부분을 병합 정렬로 정렬합니다.</li>
  <li>배열의 뒷부분을 병합 정렬로 정렬합니다.</li>
  <li>배열의 앞부분과 뒷부분을 병합합니다.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 병합 정렬 알고리즘 구현하기
</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">MutableSequence</span>


<span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">MutableSequence</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="s">"""병합 정렬"""</span>

    <span class="k">def</span> <span class="nf">_merge_sort</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">MutableSequence</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""a[right] ~ a[left]를 재귀적으로 병합 정렬"""</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="n">_merge_sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>    <span class="c1"># 배열 앞부분을 병합 정렬
</span>            <span class="n">_merge_sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">center</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>   <span class="c1"># 배열 뒷부분을 병합 정렬
</span>
            <span class="c1"># 앞부분과 뒷부분을 병합하는 과정-------------------------------
</span>            <span class="n">p</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="o">=</span> <span class="n">left</span>

            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">center</span><span class="p">:</span>
                <span class="n">buff</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">buff</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">buff</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">buff</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># 앞부분과 뒷 부분을 병합하는 과정-------------------------------
</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">buff</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>           <span class="c1"># 작업용 배열을 생성
</span>    <span class="n">_merge_sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>      <span class="c1"># 배열 전체를 병합 정렬
</span>    <span class="k">del</span> <span class="n">buff</span>

</code></pre></div></div>

<p>배열 병합의 시간 복잡도는 O(n)입니다. 데이터 원소 수가 n일 때 병합 정렬의 단계는 log n만큼 필요하므로 전체 시간 복잡도는 O(n logn)입니다. 병합 정렬 알고리즘은 서로 떨어져 있는 우너소를 교환하는 것이 아니므로 안정적입니다.</p>
:ET