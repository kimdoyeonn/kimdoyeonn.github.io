---
title: ' 17장 생성자 함수에 의한 객체 생성'
date: 2022-02-09
category: DeepDive
draft: false
---

- 교재: 모던 자바스크립트 Deep Dive

### 생성자 함수란?

new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 여기서 인스턴스란 생성자 함수에 의해 생성된 객체를 말한다. 예시를 들어 보자면 생성자함수는 붕어빵 틀, 인스턴스는 붕어빵 틀에 의해 만들어진 붕어빵이라고 할 수 있다.

객체를 생성할 때는 생성자 함수로 생성하는 방법과 객체 리터럴로 생성하는 방법이 있다.

```js
// 객체 리터럴로 생성
const increase = {
  value: 0,
  plus() {
    this.value++
    return this.value
  },
}

// 생성자 함수로 생성
function Increase() {
  this.value = 0
  this.plus = function() {
    this.value++
    return this.value
  }
}

const number = new Increase()
```

이렇게 생성 예시만 보면 객체리터럴로 생성하는 것이 더 직관적이고 간편하다.

하지만 객체 리터럴 생성 방식에는 단점이 있다. 바로 한 번에 하나의 객체만 생성 할 수 있다는 것이다. 때문에 만약 동일한 프로퍼티를 가지는 객체 여러 개를 생성해야 하는 경우, 객체 리터럴 방식으로 생성하려면 객체를 하나하나 다 생성해야하므로 생성해야 하는 객체가 많을수록 비효율적이다.

그에 비해 생성자 함수에 의한 객체 생성 방식은 동일한 프로퍼티를 가지는 객체를 생성해야 하는 경우 생성자 함수를 템플릿(클래스)처럼 사용하므로 객체 리터럴에 의한 객체 생성 방식에 비해 훨씬 효율적이다.

### 생성, 사용 방법

1. 일반 함수와 동일한 방법으로 생성자 함수를 정의한다.

   ```js
   function Increase() {
     this.value = 0
     this.plus = function() {
       this.value++
     }
   }
   ```

2. 생성된 함수를 new 연산자와 함께 사용하면 생성자 함수로 동작한다.

### 생성자 함수에 의한 인스턴스 생성 과정

1. 인스턴스 생성 & this 바인딩(런타임 이전)

   빈 객체가 생성되고, 생성된 빈 객체가 this와 바인딩된다.
   바인딩은 식별자와 값을 연결하는 과정을 말한다. 빈 객체와 this가 바인딩 되면서 이후 명시되는 this는 모두 해당 인스턴스를 가리키게 된다.

2. 생성된 인스턴스를 초기화(런타임)

   - 바인딩된 this에 프로퍼티와 메서드가 추가된다.
   - 바인딩된 this에 생성자 함수의 인수로 받은 값이 초기값으로 프로퍼티에 할당되거나 고정값을 할당한다.
   - 이 과정은 개발자에 의해 작성된 코드에 따라 진행된다.

3. 인스턴스 반환
   생성자함수에는 return을 명시하지 않아도 암묵적으로 완성된 인스턴스가 바인딩된 this가 반환된다. 만약 return을 명시하여 객체를 반환할 경우 this 반환은 무시되고 명시된 객체를 반환하게 된다. 객체가 아니라 원시값을 반환할 경우에는 원시값 반환이 무시되고 this가 반환된다.

   이처럼 생성자함수에 return을 명시하는 것은 생성자 함수의 기본 동작을 훼손하기 때문에 생성자 함수 내부에 return문은 반드시 생략하여야 한다.

### 일반 함수와 생성자 함수의 차이점

자바스크립트에서 함수는 객체로 분류된다. 하지만 일반 객체와는 다르게 호출할 수 있다는 특징을 가지고 있다. 이는 함수가 일반 객체가 가지고 있는 내부 슬롯, 내부 메소드에 함수 객체로서 동작하기 위한 내부 슬롯과 내부 메소드를 가지고 있기 때문이다. 호출이 가능하게 만드는 `[[Call]]`과 생성자 함수인지 아닌지를 결정하는 `[[Construct]]`라는 메서드들의 유무에 의해 일반 객체와 함수, 일반 함수와 생성자 함수가 결정된다.

- `[[Call]]`: 함수 객체가 일반 함수로서 호출될 때 호출된다. 이 메서드를 가진 객체는 callable이라고 하며 호출할 수 있는 객체, 즉, 함수를 뜻한다.

- `[[Construt]]`: new 연산자와 함께 생성자 함수로서 호출될 때 호출된다. 이 메서드르 가진 객체는 constructor라고 하며, 가지지 않은 객체는 non-constructor라고 한다.

_모든 함수 객체는 callable이지만, 모든 함수 객체가 constructor이다._

### constructor와 non-constructor의 구분

**함수의 정의 방식**에 따라 구분된다.

- constructor: 함수 선언문, 함수 표현식, 클래스
- non-constructor: 메서드(ES6 메서드 축약 표현), 화살표 함수

메서드는 함수(클래스) 내부에 프로퍼티로 선언된 함수 중에 ES6 메서드 축약 표현으로 생성된 메서드만 non-constructor이다.

일반 함수와 생성자 함수를 정의하는 방식에는 차이가 없으므로 둘을 구분하기 위해 생성자 함수를 정의할 때는 첫 글자를 대문자로 작성하는 파스칼 방식으로 함수를 작성하도록 해야 한다.

### new.target

생성자 함수를 호출할 때 new 연산자와 함께 호출하였는지 확인하는 장치이다.

new와 함께 호출된 생성자 함수에서 `new.target`은 해당 함수 자기 자신을 가리키고, new 없이 호출된 생성자 함수에서는 `undefined`이다. 이를 이용하여 new 연산자와 함께 호출되지 않은 생성자 함수를 재귀적으로 new와 함께 호출하도록 만들 수 있다.

```js
function Increase(number) {
  if (!new.target) {
    return new Increase(number)
  }

  this.value = number
  this.plus = () => {
    this.value++
  }
}
```

`new.target`은 ES6 문법이라 IE에서 지원하지 않기 때문에 유의해서 사용해야 한다. `new.target` 문법을 사용할 수 없는 경우에는 `스코프 세이브 생성자 패턴`을 사용할 수도 있다.

```js
// 스코프 세이브 생성자 패턴
function Increase(number) {
  if (!(this instanceof Increase)) {
    return new Increase(number)
  }

  this.value = number
  this.plus = () => {
    this.value++
  }
}
```

### 빌트인 생성자 함수

대부분의 빌트인 생성자 함수들은 new 연산자와 같이 생성하지 않아도 함께 호출했을 때와 동일하게 동작한다. 몇 가지 예외는 `Number()`, `String()`, `Boolean()`인데 이것들은 new 연산자 없이 호출할 경우 각각 데이터 타입에 해당하는 값을 반환한다. 때문에 이를 이용하여 데이터 타입을 변경할 때 사용하기도 한다.
