---
title: "[doit_algorithm] 06-8 힙 정렬"
excerpt: ""
category:
  - doit_algorithm
tags: [python, doit_algorithm]
---

참고: doit 자료구조와 함께 배우는 알고리즘 입문



#### 힙정렬 알아보기

힙정렬(heap sort)는 힙의 특성을 이용하여 정렬하는 알고리즘입니다. 힙은 '부모의 값이 자식의 값보다 항상 크다'는 조건을 만족하는 완전 이진 트리입니다. 이때 부모의 값이 자식의 값보다 항상 작아도 힙이라고 합니다. 즉, 이러한 두 값의 대소 관계가 일정하면 됩니다.

>힙(heap)은 '쌓아놓음', '쌓아 놓은 더미'라는 뜻

힙에서 어떤 부모와 자식 관계를 주목할 때 '부모의 값' >= '자식의 값' 인 관계가 항상 성립합니다. 따라서 힙의 가장 위쪽에 위치한 루트가 가장 큰 값이 됩니다. 

> * 트리
>
>   트리는 각 원소를 의미하는 노드(node)들이 연결된 계층 구조입니다. 트리의 가장 윗부분에 위치한 루트(root)는 부모가 없는 노드입니다. 노드의 상하 관계에는 부모노드(parent node)와 자식노드(child node)가 있습니다. 그리고 부모가 같은 자식 간의 관계를 형제노드(sibling)라고 합니다.
>
>   완전 이진 트리란 트리의 한 종류로 완전 이진 상태라는 특징이 있습니다. 여기서 "완전"은 부모는 왼쪽 자식부터 추가하여 모양을 유지하라는 뜻입니다. 그리고 '이진'은 부모가 가질 수 있는 자식의 최대 개수는 2개라는 의미입니다.



힙에서 부모와 자식 관계는 일정하지만 형제 사이의 대소 관계는 일정하지 않습니다. 따라서 힙은 형제의 대소 관계가 정해져 있지 않으므로 부분 순서 트리(partial ordered tree)라고도 합니다.



### 힙정렬의 특징

힙 정렬은 '힙에서 최댓값은 루트에 위치한다.'는 특징을 이용하여 정렬하는 알고리즘입니다.

- 힙에서 최댓값인 루트를 꺼냅니다.
- 루트 이외의 부분을 힙으로 만듭니다.

이 과정에서 꺼낸 값을 나열하면 정렬이 끝난 배열이 완성됩니다. 즉, 힙 정렬은 선택 정렬을 응용한 알고리즘입니다. 

또한 힙 정렬에서 최댓값인 루트를 꺼낸 뒤 다시 남은 원소 중에서 최댓값을 구해야 합니다. 예를 들어 힙으로 이루어진 원소 10개에서 최댓값을 꺼내면 남은 9개 원소에서 다시 최댓값을 구해야합니다. 따라서 남은 9개 원소로 구성한 트리도 힙이 되도록 재구성해야 합니다.

> 선택정렬: 최솟값 또는 최댓값을 선택해 정렬하는 알고리즘



### 루트를 삭제한 힙의 재구성

1. 루트를 꺼냅니다.
2. 마지막 원소(가장 하단의 오른쪽에 위치한 원소)를 루트로 이동합니다.
3. 루트에서 시작하여 자신보다 값이 큰 자식과 자리를 바꾸고 아래쪽으로 내려가는 작업을 반복합니다. 자식의 값이 작서나 리프의 위치에 도달하면 종료합니다.

>리프(leaf)는 트리에서 자식이 없는 노드를 말하며 잎 노드, 말단 노드라고도 합니다.



### 힙정렬 알고리즘 알아보기

1. i값을 n-1로 초기화합니다.
2. a[0]과 a[i]를 교환합니다.
3. a[0], a[1], ... , a[i - 1]을 힙으로 만듭니다.
4. i값을 1씩 감소시켜 0이 되면 종료합니다. 그렇지 않으면 2로 돌아갑니다.

이 떄 중요한 것은 배열의 처음 상태가 힙의 요구 사항을 만족하지 않을 수도 있다는 것입니다. 따라서 이 순서를 적용하기 전에 배열을 반드시 힙으로 만들어야 합니다.



### 배열을 힙으로 만들기

```python
from typing import MutableSequence


def heap_sort(a: MutableSequence) -> None:
    """힙 정렬"""

    def down_heap(a: MutableSequence, left: int, right: int) -> None:
        """a[left] ~ a[right]를 힙으로 만들기"""
        temp = a[left]          # 루트

        parent = left
        while parent < (right + 1) // 2:
            cl = parent * 2 + 1             # 왼쪽 자식
            cr = cl + 1                     # 오른쪽 자식
            child = cr if cr <= right and a[cr] > a[cl] else cl     # 큰 값을 선택
            if temp >= a[child]:
                break
            a[parent] = a[child]
            parent = child
        a[parent] = temp

    n = len(a)

    for i in range((n-1) // 2, -1, -1):     # a[i] ~ a[n-1]을 힙으로 만들기
        down_heap(a, i, n-1)

    for i in range(n-1, 0, -1):
        a[0], a[i] = a[i], a[0]             # 최댓값인 a[0]와 마지막 원소를 교환
        down_heap(a, 0, i - 1)              # a[0] ~ a[i - 1]을 힙으로 만들기
```

#### down_heap() 함수

배열 a에서 a[left] ~ a[right] 원소를 힙으로 만듭니다. a[left] 이외에는 모두 힙 상태라고 가정하고 a[left]를 아랫부분의 알맞은 위치로 옮겨 힙 상태를 만듭니다.

#### heap_sort() 함수

원소 수가 n인 배열 a를 힙 정렬하는 함수입니다.

- 1단계: down_sort()함수를 호출하여 배열 a를 힙으로 만듭니다.
- 2단계: 최댓값인 루트 a[0]을 꺼내 배열의 마지막 우너소와 교환하고, 배열의 남은 부분을 다시 힙으로 만드는 과정을 반복하여 정렬을 수행합니다.



### 힙 정렬의 시간 복잡도

힙 정렬은 선택 정렬을 응용한 알고리즘 입니다. 단숱 선택 정렬은 아직 정렬하지 않은 부분의 모든 원소 중에서 최대값을 선택합니다. 힙 정렬은 맨 앞 원소를 꺼내는 것 만으로 최댓값을 구할 수 있지만 남은 원소를 힙으로 재구성해야 합니다.

단순 선택 정렬에서 최댓값인 원소를 선택하는 시간 복잡도는 O(n)이지만, 힙 정렬에서 다시 힙으로 만드는 작업의 시간 복잡도는 O(log n)으로 크기 줄어듭니다.



#### heapq 모듈을 사용하는 힙 정렬

파이썬 heapq 모듈은 힙에 원소를 추가하는 heapqush() 함수와 힙에서 원소를 제거하는 heappop() 함수를 제공합니다. 이때 푸시와 팝은 힙의 조건을 유지하며 수행됩니다. 따라서 heapq모듈을 사용하면 힙 정렬을 간결하게 구현할 수 있습니다. heap에 전체 원소를 푸시하고 꺼내는 작업을 합니다.

```python
import heapq
from typing import MutableSequence


def heap_sort(a: MutableSequence) -> None:
    """힙 정렬(heap.qpush와 heapq.pop를 적용)"""

    heap = []
    for i in a:
        heapq.heappush(heap, i)
    for i in range(len(a)):
        a[i] = heapq.heappop(heap)
```