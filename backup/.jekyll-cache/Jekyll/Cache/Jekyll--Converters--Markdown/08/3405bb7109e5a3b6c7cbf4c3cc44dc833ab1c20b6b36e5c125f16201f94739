I",<p>참고: doit 자료구조와 함께 배우는 알고리즘 입문</p>

<h4 id="이진-트리">이진 트리</h4>

<p>노드가 왼쪽 자식과 오른쪽 자식만을 갖는 트리를 이진 트리라고 합니다. 이때 두 자식 가운데 하나 또는 둘다 존재하지 않는 노드가 있어도 상관없습니다.</p>

<p>왼쪽 자식을 루트로 하는 서브트리를 왼쪽 서브트리, 오른 쪽 자식을 루트로 하는 서브트리를 오른쪽 서브트리라고 합니다.</p>

<h4 id="완전-이진-트리">완전 이진 트리</h4>

<p>루트부터 아래쪽 레벨로 노드가 가득 차 있고, 같은 레벨 안에서 왼쪽부터 오른쪽으로 노드가 채워져 있는 이진 트리를 완전 이진 트리라고 합니다.</p>

<ul>
  <li>마지막 레벨을 제외하고 모든 레벨에 노드가 가득 차 있습니다.</li>
  <li>마지막 레벨에 한해서 왼쪽부터 오른쪽으로 노드를 채우되 반드시 끝까지 채우지 않아도 됩니다.</li>
</ul>

<p>높이가 k인 완전 이진 트리가 가질 수 있는 노드의 수는 최대 2^(k+1)-1개이므로, n개의 노드를 저장할 수 있는 완전 이진 트리의 높이는 log n입니다.</p>

<h4 id="이진-검색-트리">이진 검색 트리</h4>

<ul>
  <li>왼쪽 서브트리 노드의 키값은 자신의 노드 키값보다 작아야 합니다.</li>
  <li>오른쪽 서브트리 노드의 키값은 자신의 노드 키값보다 커야 합니다.</li>
  <li>키값이 같은 노드는 복수로 존재하지 않습니다.</li>
</ul>

<p>이진 검색 트리는 다음과 같은 특징이 있어서 알고리즘에서 폭 넓게 사용되고 있습니다.</p>

<ul>
  <li>구조가 단순합니다.</li>
  <li>중위 순회의 깊이 우선 검색을 통하여 노드값을 오름차순으로 얻을 수 있습니다.</li>
  <li>이진 검색과 비슷한 방식으로 아주 빠르게 검색할 수 있습니다.</li>
  <li>노드를 삽입하기 쉽습니다.</li>
</ul>

<p><strong>검색</strong></p>

<ol>
  <li>
    <p>루트에 주목합니다. 여기서 주목하는 노드를 p</p>
  </li>
  <li>
    <p>p가 None이면 검색을 실패하고 종료</p>
  </li>
  <li>
    <p>검색하는 key와 주목 노드p의 키를 비교합니다.</p>

    <ul>
      <li>
        <p>key = p: 검색 성공, 종료</p>
      </li>
      <li>key &lt; p: 주목 노드를 왼쪽 자식 노드로 옮김</li>
      <li>key &gt; p: 주목 노드를 오른쪽 자식 노드로 옮김</li>
    </ul>
  </li>
  <li>
    <p>2번 과정으로 되돌아감</p>
  </li>
</ol>

<p><strong>삽입</strong></p>

<ul>
  <li>노드를 삽입한 뒤에 트리의 형태가 이진 검색 트리의 조건을 유지해야한다. 따라서 노드를 삽입할 때에는 검색할 때와 마찬가지로 먼저 삽입할 위치를 찾아낸 뒤에 수행해야 합니다.</li>
</ul>

<ol>
  <li>루트에 주목합니다. 여기서 주목하는 노드를 node라고 하겠습니다.</li>
  <li>삽입하는 key와 주목 노드 node의 키를 비교합니다.
    <ul>
      <li>key = node인 경우: 삽입을 실패하고 종료합니다.</li>
      <li>key &lt; node인 경우:
        <ul>
          <li>왼쪽 자식 노드가 없으면, 그 자리에 삽입하고 종료합니다.</li>
          <li>왼쪽 자식 노드가 있으면, 주목 노드를 왼쪽 자식 노드로 옮깁니다.</li>
        </ul>
      </li>
      <li>key &gt; node인 경우:
        <ul>
          <li>오른쪽 자식 노드가 없으면, 그 자리에 노드를 삽입하고 종료합니다.</li>
          <li>오른쪽 자식 노드가 있으면, 주목 노드를 오른쪽 자식 노드로 옮깁니다.</li>
        </ul>
      </li>
      <li>2번 과정으로 되돌아 갑니다.</li>
    </ul>
  </li>
</ol>

<p><strong>삭제</strong></p>

<ul>
  <li>
    <p>자식 노드가 없는 노드를 삭제하는 경우</p>

    <ul>
      <li>삭제할 노드가 부모 노드의 왼쪽 자식이면, 부모의 왼쪽 포인터를 None으로 합니다.</li>
      <li>삭제할 노드가 부모 노드의 오른쪽 자식이면, 부모의 오른쪽 포인터를 None으로 합니다.</li>
    </ul>
  </li>
  <li>
    <p>자식 노드가 1개인 노드를 삭제하는 경우</p>

    <ul>
      <li>
        <p>삭제할 노드가 부모 노드의 왼쪽 자식인 경우</p>

        <p>부모의 왼쪽 포인터가 삭제할 노드의 자식을 가리키도록 업데이트합니다.</p>
      </li>
      <li>
        <p>삭제할 노드가 부모 노드의 오른쪽 자식인 경우</p>

        <p>부모의 오른쪽 포인터가 삭제할 노드의 자식을 가리키도록 업데이트합니다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>자식 노드가 2개인 노드를 삭제하는 경우</p>

    <ol>
      <li>삭제할 노드의 왼쪽 서브트리에서 키값이 가장 큰 노드를 검색합니다.</li>
      <li>검색한 노드를 삭제 위치로 옮깁니다. 즉, 검색한 노드의 데이터를 삭제할 노드 위치에 복사합니다.</li>
      <li>옮긴 노드를 삭제합니다. 이때 자식 노드의 개수에 따라 다음을 수행합니다.
        <ul>
          <li>옮긴 노드에 자식이 없으면: ‘자식 노드가 없는 노드의 삭제’에 따라 노드를 삭제합니다.</li>
          <li>옮긴 노드에 자식이 1개만 있으면: ‘자식 노드가 1개인 노드의 삭제’에 따라 노드를 삭제합니다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p><strong>모든 노드를 오름차순으로 출력</strong></p>

<p>중위 순회의 깊이 우선 검색으로 스캔</p>

:ET