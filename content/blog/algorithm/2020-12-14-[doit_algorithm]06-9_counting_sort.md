---
title: "[doit_algorithm] 06-9 도수 정렬"
excerpt: ""
category:
  - doit_algorithm
tags: [python, doit_algorithm]
---

참고: doit 자료구조와 함께 배우는 알고리즘 입문



#### 도수 정렬 알아보기

도수 정렬(counting sort)은 원소의 대소 관계를 판단하지 않고 빠르게 정렬하는 알고리즘으로, 분포수 세기(distribution counting)정렬이라고도 합니다.

지금까지 학습한 정렬 알고리즘에서는 두 우너소의 키값을 비교하여 정렬했습니다. 하지만 도수 정렬은 원소를 비교할 필요가 없다는 특징이 있습니다.

1. 도수 분포표 만들기

   정렬하려는 배열의 데이터 범위 크기의 배열을 만들고, 대상 정렬을 스캔하면서 각각 몇개의 데이터가 존재하는지 정리한다.

   확률과 통계에서 자주 등장하는 용어인 도수 분포표는 자료를 몇 개의 등급으로 나누고 각 등급에 속하는 도수를 조사하여 나타낸 표를 의미합니다. 여기에서 도수는 각 등급에 속하는 재료의 개수입니다.

2. 누적 도수 분포표 만들기

   다음으로 0부터 n까지 몇명이 있는지 를 누적된 값으로 나타내는 누적 도수 분포표를 만듭니다. 배열의 두 번째 원소부터 바로 앞의 원솟값을 더하는 과정을 나타냅니다.

3. 작업용 배열 만들기

   앞 단계에서 각 점수를 받은 학생이 몇 번째에 위치하는지 알 수 있으므로 이 시점에서 정렬은 거의 마쳤다고 할 수 있습니다. 

   남은 작업은 정렬하려는 배열의 각 원솟값과 누적 도수 분포표를 대조하여 정렬을 완료한 배열을 만드는 것입니다. 이 작업에서 원소 수가 동일한 작업용 배열이 필요합니다. 정렬하려는 배열의 우너소를 맨 끝에서 맨 앞으로 스캔하면서 누적 도수분포표와 대조합니다.

4. 배열 복사하기

   정렬은 완료되었지만 정렬한 결과가 저장되어 있는 곳은 작업용 배열이므로 정렬하려는 배열은 아직 정렬 전 의 상태입니다. 그러므로 for문을 수행하여 작업용 배열의 모든 원소를 그대로 복사합니다.

도수 정렬은 if문을 사용하지 않고 for문만 반복해서 정렬할 수 있는 알고리즘입니다. 

```python
# 도수 정렬 알고리즘 구현하기

from typing import MutableSequence


def fsort(a: MutableSequence, max: int) -> None:
    """도수 정렬(배열 원솟값은 0 이상 max 이하)"""
    n = len(a)                  # 정렬할 배열 a
    f = [0] * (max + 1)         # 누적 도수 분포표 배열 f
    b = [0] * n                 # 작업용 배열 b

    for i in range(n):
        f[a[i]] += 1        # 1단계
    for i in range(1, max+1):
        f[i] += f[i-1]      # 2단계
    for i in range(n-1, -1, -1):
        f[a[i]] -= 1
        b[f[a[i]]] = a[i]     # 3단계
    for i in range(n):
        a[i] = b[i]         # 4단계


def counting_sort(a: MutableSequence) -> None:
    """도수 정렬"""
    fsort(a, max(a))


if __name__ == "__main__":
    print("도수 정렬을 수행합니다.")
    num = int(input("원소 수를 입력하세요: "))
    x = [None] * num                            # 원소 수가 num인 배열을 생성

    for i in range(num):                        # 양수만 입력받도록 제한
        while True:
            x[i] = int(input(f'x[{i}]: '))
            if x[i] >= 0:
                break

    counting_sort(x)                            # 배열 x를 도수 정렬

    print("오름차순으로 정렬했습니다.")
    for i in range(num):
        print(f'x[{i}] = {x[i]}')

```

fsort() 함수는 도수 정렬을 수행합니다. 배열의 모든 원솟값이 0 이상 max 이하라는 것을 전제로 해서 배열 a를 정렬합니다. counting_sort()함수는 배열 a와 그 원소의 최댓값 max(a)를 fsort()함수에 전달하여 호출합니다.



도수 정렬 알고리즘은 데이터 비교, 교환작업이 필요 없어 매우 빠릅니다. 프로그램에서는 단일 for문만 사용하고 재귀 호출이나 이중 if문이 없어 매우 효율이 좋은 알고리즘입니다. 하지만 도수 분포표가 필요하므로 데이터의 최솟값과 최댓값을 미리 알고있는 경우에만 적용할 수 있습니다.

각 단계(for문)에서 배열 우너소를 건너뛰지 않고 순서대로 스캔하므로 이 정렬 알고리즘은 안정적입니다. 그러나 3단계에서 배열 a를 스캔할 때 맨 앞부터 스캔하면 안정적이지 않다는 점을 주의해야 합니다.

> 앞에서 뒤로 스캔하면 안정적이지 않은 이유는 원솟값이 같을 경우 실행순서가 뒤바뀌는 것을 보면 확인할 수 있습니다. 즉, 같은 키 값의 순서 관계가 정렬 전후로 뒤바뀝니다.