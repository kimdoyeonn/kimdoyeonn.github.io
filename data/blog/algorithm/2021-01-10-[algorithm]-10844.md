---
title: '[algorithm]10844 쉬운 계단 수'
excerpt: ''
category:
  - algorithm
tags: [python, baekjoon, algorithm]
---

참고: [백준](https://www.acmicpc.net/problem/10844)

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 1 초      | 256 MB      | 69979 | 21185 | 15213     | 28.399%   |

## 문제

45656이란 수를 보자.

이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.

세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)

## 입력

첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

## 예제 입력 1 복사

```
1
```

## 예제 출력 1 복사

```
9
```

## 예제 입력 2 복사

```
2
```

## 예제 출력 2 복사

```
17
```

#### 내 풀이

```python
n = int(input())

dp = [[], [0] * 10]

for j in range(1, 10):
    dp[1][j] = 1

for i in range(2, n+1):
    temp = [0] * 10
    for j in range(0, 10):
        if j == 0:
            temp[j] = dp[i-1][j+1]
        elif j == 9:
            temp[j] = dp[i-1][j-1]
        else:
            temp[j] = dp[i-1][j+1] + dp[i-1][j-1]
    dp.append(temp)
print(sum(dp[n]) % 1000000000)
```

<img src="https://user-images.githubusercontent.com/53068706/107882585-80cc0d80-6f2d-11eb-99d2-fbf36669cb1c.PNG" alt="10844_1"  />

2차원 배열을 사용하였다. `dp[n][m]` n = 자릿수, m=끝자리

m = 1~8일 때 다음에 올 수 있는 수는 m-1, m+1이다. 나머지는 예외인 숫자인데 m=0인 경우에는 0보다 작은 수는 나올 수 없으므로 다음엔 1밖에 올 수 없고, m=9인 경우에도 9보다 큰 경우는 없으므로 다음에 올 수 있는 수는 8밖에 없다.

첫자리로 나올 수 없는 0을 제외한 모든 수에 1이 들어간 리스트를 바탕으로 두번쨰 자리 수의 경우를 구하는데 앞자리가 1인 경우 0,2가 나올 수 있으므로 `dp[1][0] + dp[1][2]`를 넣어주었고 앞자리가 2인 경우 `dp[1][1] + dp[1][3]`을, 앞자리가 3인 경우 `dp[1][2] + dp[1][4]`를 넣어주는 식으로 끝자리수의 개수를 원하는 자릿수만큼 계산 한 후 마지막 자릿수의 연산을 마친 후에 마지막 리스트의 합을 구해 출력했다.
