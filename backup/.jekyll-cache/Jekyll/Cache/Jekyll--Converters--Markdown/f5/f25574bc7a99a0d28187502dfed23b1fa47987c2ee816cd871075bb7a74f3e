I"<ul>
  <li>마이크로 명령어 집합과 구성
    <ul>
      <li>명령어(instruction) 집합</li>
      <li>주소 지정 모드(addressing mode)</li>
    </ul>
  </li>
</ul>

<h3 id="명령어-집합">명령어 집합</h3>

<h4 id="실행-순서에-따른-명령어-분류">실행 순서에 따른 명령어 분류</h4>

<ul>
  <li>
    <p>순차적 실행 명령어 - 전체 실행 명령어의 70~80% 차지 / 가장 익숙한 타입</p>
  </li>
  <li>
    <p>분기 명령어</p>

    <p>예) <code class="language-plaintext highlighter-rouge">P: R1 &lt;- R2</code> (<code class="language-plaintext highlighter-rouge">if (P == 1) then R1 &lt;- R2</code>)</p>
  </li>
  <li>
    <p>부 함수 호출 명령어</p>

    <p>메인과 서브로 나누어져있고 메인이 실행되는 중간에 서브가 실행된 후 서브의 실행이 끝나면 메인으로 피드백된다</p>
  </li>
  <li>
    <p>복귀 명령어</p>
  </li>
</ul>

<p><img src="https://media.vlpt.us/images/underlier12/post/6162defa-8287-46f8-ba09-34def22c553c/image.png" alt="img" /></p>

<h4 id="명령어-구문-형식">명령어 구문 형식</h4>

<p><img src="https://media.vlpt.us/images/underlier12/post/ab393698-4e8c-4759-88ff-fac052438d4a/image.png" alt="img" style="zoom: 67%;" /></p>

<blockquote>
  <p>프로그램과 하드웨어 간의 독립성을 위해 direct mode에서 indirect mode로 변화하였다.</p>
</blockquote>

<ol>
  <li>명령 코드 : CPU가 실행할 수 있도록 디자인 된 연산</li>
  <li>오퍼랜드 : 연산에 사용되는 자료 값, 자료가 지정 된 주소에 관한 정보</li>
  <li>주소 지정 모드(addressing mode) : 오퍼랜드가 저장된 위치를 인덱싱(지정)하는 방법</li>
</ol>

<h4 id="명령어-집합의-설계">명령어 집합의 설계</h4>

<blockquote>
  <p>마이크로 연산 등등</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th>설계관점</th>
      <th>자연어에 가까운 명령 코드</th>
      <th>기계 중심의 명령 코드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>프로그램의 관점(SW)</td>
      <td>- 프로그램이 용이<br />- 전체 프로그램의 길이 감소<br />- 번역기의 설계 용이</td>
      <td>- 프로그래밍규칙이 많아짐<br />- 프로그램의 길이가 증가<br />- 번역기의 설계가 복잡해짐</td>
    </tr>
    <tr>
      <td>CPU 구조 설계 관점(HW)</td>
      <td>- 사용 언어에 따른 구조적 차이로 인해 오동작 및 처리 어려움<br />- 명령어의 길이 증가<br />- 제어장치(ALU, Register 등)의 제어가 매우 복잡해짐</td>
      <td>- 다양한 업체별 국가별 프로그래밍의 표준화가 가능<br />- 명령어의 종류 및 길이 등 간편화 될 수 있음<br />- 제어장치(ALU, Register 등)의 제어가 상대적으로 용이</td>
    </tr>
  </tbody>
</table>

<h4 id="현업에서-활용되는-명령어군의-활용-비율">현업에서 활용되는 명령어군의 활용 비율</h4>

<table>
  <thead>
    <tr>
      <th>명령 코드</th>
      <th>실행 비율</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>load, store, move</td>
      <td>38% ➡자료전송 명령어</td>
    </tr>
    <tr>
      <td>compare, add, and, sub</td>
      <td>35% ➡산술/논리 연산 명령어</td>
    </tr>
    <tr>
      <td>condition, blench, call, return</td>
      <td>22% ➡실행제어 명령어</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>위의 명령어가 전체 실행 명령어의 약 90% 이상임</p>

  <p>위의 명령어들의 쓰임을 면밀이 연구를 해야 ALU, CPU의 개선을 담보할 수 있을 것임</p>
</blockquote>

<h3 id="주소-지정-모드addressing-mode">주소 지정 모드(addressing mode)</h3>

<blockquote>
  <p>찾아볼 것: <strong>명령어 구문 형식</strong></p>
</blockquote>

<p>명령어의 구조상 자료가 저장되어 있는 장소를 지정하는 방법이 필요하다. (하드웨어와 소프트웨어의 독립성을 최대한 유지하여 프로그램의 유연성(pointer, indexing 등)을 가능하게 하여 명령어의 수와 길이를 줄이기 위해 - 세계 표준화 기법임)</p>

<h4 id="묵시적-모드operand가-명령어에-포함되어--있지-않은-특수-모드">묵시적 모드(operand가 명령어에 포함되어  있지 않은 특수 모드)</h4>

<ul>
  <li>NOP : NO operation, 오퍼랜드가 필요없는 명령어</li>
  <li>INC : 묵시적 오퍼랜드인 누산기(AC)의 연산 명령어</li>
  <li>ADD : 스택 구조의 명령어(스택에 오퍼랜드가 저장)</li>
</ul>

<h4 id="직접-값-모드operand-자체가-명령어에-포함되어-있는-모드">직접 값 모드(operand 자체가 명령어에 포함되어 있는 모드)</h4>

<p>ex ) <code class="language-plaintext highlighter-rouge">MOV R1, #100;</code> 십진수 값 100이 두번째 오퍼랜드로 직접 명령문에 포함되어 있는 경우</p>

<h4 id="레지스터-모드register-mode--오퍼랜드가-레지스터에-저장된-모드">레지스터 모드(Register mode : 오퍼랜드가 레지스터에 저장된 모드)</h4>

<p>ex ) <code class="language-plaintext highlighter-rouge">ADD R1 R2;</code> 레지스터 R1과 R2에 보유하고 있는 값이 오퍼랜드임</p>

<h4 id="메모리-직접-주소-모드direct-mode--오퍼랜드가-저장된-메모리-주소를-나타내는-모드">메모리 직접 주소 모드(Direct mode : 오퍼랜드가 저장된 메모리 주소를 나타내는 모드)</h4>

<p>ex ) <code class="language-plaintext highlighter-rouge">MOV R1, 100;</code> R1에 100번지의 내용을 이동하라는 내용(기종에 따라 반대의 경우도 가능), 100번지의 내용이 두번째 오퍼랜드가 됨</p>

<h4 id="메모리-간접-주소-모드memory-indirect-addressing-mode">메모리 간접 주소 모드(Memory indirect addressing mode)</h4>

<p>메모리를 이용하여 간접적으로 주소를 지정하는 모드</p>

<p>ex ) <code class="language-plaintext highlighter-rouge">MOV R1, @100;</code> <code class="language-plaintext highlighter-rouge">R1 ⬅ M[100] or M[100] ⬅ R1</code></p>

<p><img src="https://media.vlpt.us/images/underlier12/post/af1bcbdf-1a72-4038-bb3d-8f103a8bc733/image.png" alt="img" style="zoom: 50%;" /></p>

<h4 id="주소-지정-모드-예">주소 지정 모드 예</h4>

<p>다음 마이크로 명령을 수행한 후, 어떤 변화가 생겼을까? (주어진 일부 메모리 내용을 참조할 것, R1 = 100, R2 = 200이라고 가정)</p>

<p><img src="https://media.vlpt.us/images/underlier12/post/2475e784-41d0-4966-963b-9c14dbef64f7/image.png" alt="img" /></p>
:ET