---
title: "[doit_algorithm] 08-2 포인터를 이용한 연결 리스트-1"
excerpt: ""
category:
  - doit_algorithm
tags: [python, doit_algorithm]
---

참고: doit 자료구조와 함께 배우는 알고리즘 입문



연결 리스트에 데이터를 삽입할 때 노드용 인스턴스를 생성하고, 데이터를 삭제할 때 노드용 인스턴스를 없애면 데이터를 옮기는 문제를 해결할 수 있다. 이러한 노드를 구현하는 클래스 Node를 만들었다. Node는 데이터용 필드 data와는 별도로 자신과 같은 클래스형의 인스턴스를 참조하기 위한 참조용 필드 next를 갖는다. 이처럼 자신과 같은 형의 인스턴스를 참조하는 필드가 있는 구조를 `자기참조(self-referential)형`이라고 한다.

여기서 data는 데이터 자체가 아니라 '데이터에 대한 참조'이고 next는 '노드에 대한 참조'이다.

뒤쪽 노드를 참조하는 필드 next를 뒤쪽 포인터라고 할 때, 뒤쪽 포인터 next에는 뒤쪽 노드에 대한 참조를 저장한다. 뒤쪽 노드가 없는 코리 노드의 뒤쪽 포인터 값은 None이다.



### 포인터로 연결 리스트 구현하기

```python
from __future__ import annotations	#1
from typing import Any, Type


class Node:
    """연결 리스트용 노드 클래스"""

    def __init__(self, data: Any = None, next: Node = None):
        """초기화"""
        self.data = data        # 데이터
        self.next = next        # 뒤쪽 포인터
```

#### 필드

- data: 데이터 (데이터에 대한 참조: 임의의 형)
- next: 뒤쪽 포인터(뒤쪽 노드에 대한 참조: Node형)



#### ` __init__()`함수

전달받은 data와 next를 해당 필드에 대입합니다. 호출할 때 모두 생략할 수 있으며, 생략할 경우에는 None으로 간주한다.

`#1` 책이 집필되던 시점에 파이썬에서는 함수에 대한 주석달기로 그 함수가 속한 클래스의 이름을 사용할 수 없다. (`__init__()`의 세번째 인수에 `:Node`라고 적으면 오류가 발생) 실습에서는 오류가 발생하지 않도록 프로그램 첫버리의 import문을 사용하여 `__future__`모듈에서 `annotations`를 불러온다. 이는 나중에 지원받을 기능을 미리 사용하기 위한 import문이라고 이해하면 된다. 나중에 파이썬이 업데이트 되어 이 기능을 공식적으로 지원해준다면 import문은 더이상 필요없다.



### 파이썬의 리스트는 자료구조가 아님

연결리스트는 임의의 위치에 원소를 삽입하거나 삭제할 때 빠르게 수행할 수 있다는 장점이 있다. 하지만 기억 영역(메모리)과 속도 면에서 배열보다 효율이 뒤떨어진다. 파이썬의 리스트는 이러한 연결 리스트의 자료구조가 아니라 모든 원소를 연속으로 메모리에 배치하는 '배열'로 내부에서 구현하고 있다. 그러므로 속도가 급격하게 떨어지지 않는다. 또 원소를 하나씩 추가, 삽입할 때마다 내부에서 메모리를 확보하거나 해제하지 않는다. 실제 필요한 메모리보다 여유있게 미리 마련해 놓기 때문이다.



### 연결 리스트 클래스 LinkedList

```python
class LinkedList:
    """연결 리스트 클래스"""

    def __init__(self) -> None:
        """초기화"""
        self.no = 0         # 노드의 개수
        self.head = None    # 머리 노드
        self.current = None  # 주목 노드

    def __len__(self) -> int:
        """연결 리스트의 노드 개수를 반환"""
        return self.no
```

#### 필드

- no: 리스트에 등록되어 있는 노드의 개수
- head: 머리 노드에 대한 참조
- current: 현재 주목하고 있는 노드에 대한 참조, 주목 포인터, 리스트에서 노드를 검색하여, 그 노드를 주목한 직후에 노드를 삭제하는 등의 용도로 사용한다.



#### 초기화하는 `__init__()`함수

노드가 하나도 없는 빈 연결 리스트를 생성한다. 머리 노드를 참조하기 위한 Node형 필드 head에 None을 대입한다. 

head는 머리 노드에 대한 참조일뿐 머리 노드 그 자체가 아님에 주의한다. 노드가 존재하지 않는 빈 열결 리스트는 head가 참조하는 곳이 없으므로(참조해야 하는 노드가 존재하지 않으므로) 그 값을 None으로 한다. 

주목 포인터 current에도 None을 대입하여 어떤 우너소도 주목하지 않는다.



#### 노드 개수를 반환하는 `__len__()`함수

연결 리스트의 노드 개수를 반환하는 함수이다. no값을 그대로 반환한다.

> 이 함수를 구현하므로써 연결 리스트를 len() 함수의 인수로 전달받을 수 있다.len()함수로 연결리스트의 노드 개수를 알아낼 수 있다.



- 빈 연결 리스트

  연결 리스트가 비어있을 때(노드가 하나도 존재하지 않을 때) head값은 None입니다. 그러므로 연결 리스트가 비어 있는지는 다음 식을 검사할 수 있다.

  ```python
  head is None	# 연결 리스트가 비어 있는지 확인
  ```

- 노드가 1개인 연결 리스트

  이 때 Node형 필드인 head가 참조하는 곳은 머리노드이다. 이 머리노드는 리스트의 꼬리 노드이기도 하므로 뒤쪽 포인터의 값은 None이다.

  head가 참조하는 뒤쪽 포인터의 값이 None이므로 연결 리스트에 존재하는 노드가 하나뿐인지는 다음 식으로 수행할 수 있다.

  ```python
  head.next is None	# 연결 리스트의 노드가 1개인지 확인
  ```

- 노드가 2개인 연결 리스트

  머리 노드는 노드 A이고, 꼬리 노드는 노드 B이다. 이 때 head가 참조하는 곳인 노드 A의 뒤쪽 포인터 next가 노드 B를 참조한다. (곧 head.next가 참조하는 곳은 노드 B). 맨 끝에 위치한 노드 B의 뒤쪽 포인터가 None이므로 연결 리스트의 노드가 2개인지는 다음 식으로 수행할 수 있다.

  ```python
  head.next.next is None	# 연결 리스트의 노드가 2개인지 확인
  ```

  뒤쪽 포인터가 아니라 데이터를 나타내는 식으로 생각해보면, 노드 A의 데이터에 대한 참조를 나타낸 식은 `head.data`이고 노드 B의 데이터에 대한 참조를 나타낸 식은 `head.next.data`이다.

위 세가지 경우의 판단은 no ==  0, no ==  1, no ==  2를 사용할 수 있다.



- 꼬리 노드의 판단 

  Node형인 변수 p가 리스트에 있는 노드를 참조한다면, 이때 p가 참조하는 노드가 연결 리스트의 꼬리 노드인지는 다음 식으로 수행할 수 있다.

  ```python
  p,next is None		# p가 참조하는 노드가 꼬리 노드인지 확인
  ```



#### 검색을 수행하는 search() 함수

인수로 주어진 데이터 data와 값이 같은 노드를 검색하는 함수이다. 검색 알고리즘은 선형 검색을 사용한다. 목적노드를 만날 때까지 머리 노드부터 순서대로 스캔한다. 

노드를 스캔할 때 다음 조건 가운데 하나만 성립해도 검색이 종료된다.

- 종료조건1: 검색 조건을 만족하는 노드를 발견하지 못하고 꼬리 노드까지 왔을 경우
- 종료조건2: 검색 조건을 만족하는 노드를 발견한 경우

```python
    def search(self, data: Any) -> int:
        """data와 값이 같은 노드를 검색"""
        cnt = 0
        ptr = self.head

        while ptr is not None:
            if ptr.data == data:
                self.current = ptr
                return cnt
            cnt += 1
            ptr = ptr.next

        return -1
```



### 데이터가 포함되어 있는지 판단하는 `__containts__()`함수

리스트에 data와 값이 같은 노드가 포함되어 있는지를 판단하는 함수이다. 포함되어 있으면 True를 반환하고, 그렇지 않으면 False를 반환한다.

> 이를 구현함으로써 연결 리스트에 in 연산자를 적용할 수 있다.

```python
    def __contains__(self, data: Any) -> bool:
        """연결 리스트에 data가 포함되어 있는지 확인"""
        return self.search(data) >= 0
```



### 머리에 노드를 삽입하는 `add_first()`함수

리스트의 맨 앞에 노드를 삽입하는 함수이다.

```python
	def add_first(self, data: Any) -> None:
        """맨 앞에 노드를 삽입"""
        ptr = self.head     # 삽입하기 전의 머리 노드
        self.head = self.current = Node(data, ptr)
        self.no += 1
```

1. 삽입하기 전의 머리 노드A를 참조하는 포인터를 ptr에 저장해 둡니다.
2. 삽입할 노드를 Node(data, ptr)로 생성합니다. 노드의 데이터는 data가 되고, 뒤쪽 포인터가 참조하는 곳은 ptr(삽입하기 전의 머리노드)이 됩니다. 이때 수행하는 대입으로 head는 삽입한 노드를 참조하도록 업데이트됩니다.

> 주목 포인터 current도 삽입한 노드를 참조하도록 업데이트합니다. (꼬리에 노드를 삽입하는 add_last()에서도 마찬가지입니다.



### 꼬리에 노드를 삽입하는 `add_last()`함수

리스트의 맨 끝에 노드를 삽입하는 함수입니다. 리스트가 비어 있는지 (head is None이 성립하는지)확인하고 그에 따라 다르게 처리합니다.

- 리스트가 비어 있을 때

  맨 앞에 노드를 삽입하는 것과 같은 처리를 수행하므로 add_first()함수를 호출한다.

- 리스트가 비어 있지 않을 때

  리스트의 맨 끝에 노드를 삽입합니다.

```python
    def add_last(self, data: Any):
        """맨 끝에 노드를 삽입"""

        if self.head is None:   # 리스트가 비어 있으면
            self.add_first(data)    # 맨 앞에 노드를 삽입
        else:
            ptr = self.head
            while ptr.next is not None:
                ptr = ptr.next
            ptr.next = self.current = Node(data, None)
            self.no += 1
```

1. 꼬리를 찾는 과정을 수행합니다. ptr이 참조하는 곳을 그 뒤쪽 포인터로 업데이트하는 과정을 반복하므로써 노드를 맨 앞부터 순서대로 스캔합니다. 

   ptr.next가 참조하는 곳이 None으로 되어 있으면 while문이 종료되는 것으로 한다.(꼬리노드)

2. 삽입하는 노드를 Node(data, None)로 생성한다. 뒤쪽 포인터를 None으로 하는 것은 맨 끝에 위치한 노드가 어떤 노드도 참조하지 않도록 하기 위한 것이다. 원래 꼬리 노드의 ptr.next가 참조하는 곳이 새로 삽입한 노드가 되도록 업데이트 한다.

