---
title: "브라우저와 그 작동 원리"
excerpt: ""
category:
  - Internet
tags: [Internet]
---

![img](https://t1.daumcdn.net/cfile/tistory/245A214D590FF63D20)







### 브라우저의 주요 기능

사용자가 선택한 자원을 서버에 요청, 브라우저에 표시

자원은 html문서, pdf, image 등 다양한 형태

자원의 주소는 URI에 의해 정해짐



브라우저는 html과 css 명세에 따라 html 파일을 해석해서 표시함

이 명세는 웹 표준화 기구인 `W3C(word wide web consortium)`에서 정함

> 과거 브라우저들은 일부만 명세에 따라 구현하고 독자적인 방법으로 확장함
>
> 결국 심각한 호환성 문제가 발생했고 때문에 요즘은 대부분 표준 명세를 따름



브라우저가 가진 인터페이스는 보통 비슷비슷한 요소들이 존재

> 브라우저의 사용자 인터페이스는 표준 명세가 없음에도 불구하고 시간이 지나면서 서로의 장점을 모방하며 갖춰지게 된 것
>
> html5 명세는 주소표시줄, 상태표시줄, 도구 모음과 같은 일반적인 요소를 제외하고 브라우저의 필수 ui를 정의하지 않았다.

- URI 입력하는 주소표시줄
- 이전, 다음 버튼
- 북마크(즐겨찾기)
- 새로고침 버튼
- 홈 버튼



### 브라우저 기본 구조

![img](https://camo.githubusercontent.com/0e3ac4e617b8eda5046f592c74a1f7e4cbfb82a5c6abe8d5699020002c1227b6/68747470733a2f2f64322e6e617665722e636f6d2f636f6e74656e742f696d616765732f323031352f30362f68656c6c6f776f726c642d35393336312d312e706e67)

- 사용자 인터페이스

  주소표시줄, 이전/다음 버튼, 북마크 등 사용자가 활용하는 서비스들 (요청한 페이지를 보여주는 창을 제회한 나머지 부분)

- 브라우저 엔진

  사용자 인터페이스와 렌더링 엔진 사이의 동작 제어

- 렌더링 엔진

  요청한 콘텐츠 표시(html 요청이 들어오면 html, css를 파싱해서 화면에 표시함)

- 통신

  http 요청과 같은 네트워크 호출에 사용(플랫폼의 독립적인 인터페이스로 구성되어있음)

- UI 백엔드

  플랫폼에서 명시하지 않은 일반적인 인터페이스, 콤보 박스 창같은 기본적인 장치를 그림

- 자바스크립트 해석기

  자바스크립트 코드를 해석하고 실행

- 자료 저장소

  쿠키 등 모든 종류의 자원을 하드 디스크레 저장하는 계층

> 크롬은 대부분의 브라우저와 달리 각 탭마다 별도의 랜더링 엔진 인스턴스를 유지하는 것이 특징이다. 각 탭은 독립된 프로세스로 처리된다.



#### 랜더링이란?

랜더링 엔진은 요청 받은 내용을 브라우저 화면에 표시해준다.

기본적으로 html, xml 문서와 이미지를 표시할 수 있음

추가로 플러그인이나 브라우저 확장 기능으로 pdf 등 다른 유형도 표시가 가능하다. 

> 추가로 확장이 필요한 유형은 바로 뜨지 않고 팝업으로 확장 여부를 묻는 것을 볼 수 있다.



- 랜더링 엔진 종류

  크롬, 사파리: 웹킷(Webkit) 엔진 사용

  파이어폭스: 게코(Gecko) 엔진 사용



**웹킷(Webkit)**: 최초 리눅스 플랫폼에 동작하기 위한 오픈소스 엔진 (애플이 맥과 윈도우에서 사파리 브라우저를 지원하기 위해 수정을 더함)



**랜더링 동작과정**

통신으로부터 요청한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 보통 8kb 단위로 전송

![img](https://camo.githubusercontent.com/b7b2e4f87463a5508b6cc434e99d58c48b5b8ba1aa8a4d917d9d240fd94aebf1/68747470733a2f2f64322e6e617665722e636f6d2f636f6e74656e742f696d616765732f323031352f30362f68656c6c6f776f726c642d35393336312d322e706e67)

1. html 문서를 파싱

2. 콘텐츠 트리 내부에서 태그를 모두 DOM 노드로 변환

3. 외부 css 파일과 함께 포함된 스타일 요소를 파싱 

   (이 스타일 정보와 html 표시 규적은 렌더 트리라고 부르는 또 다른 트리를 생성한다.)

   랜더트리는 색상 또는 면적과 같은 시각적 속성이 있는 사각형을 포함하고 있는데 정해진 순서대로 화면에 표시된다.

4. 랜더트리 생성이 끝나면 배치가 시작되는데, 각 노드가 화면의 정확한 위치에 표시된다.

5. UI 백엔드에서 렌더 트리의 각 노드를 가로지으며 형상을 만드는 그리기 과정이 진행된다.

6. 위의 모든 과정이 점진적으로 진행되며, 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 모든 html을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다. 

   네트워크로부터 나머지 내용 전송을 기다리는 동시에 받은 내용의 일부를 먼저 화면에 보여주는 것!

   > 우리가 웹페이지에 접속할 때 한꺼번에 뜨지 않고 점점 화면에 채워지는 것이 이 때문이다.



#### DOM이란?

Document Object Model(문서 객체 모델)

웹페이지 소스를 까보면 `<html>,<body>`와 같은 태그들이 존재한다. 이를 Javascript가 활용할 수 있는 객체로 만들면 `문서객체`가 된다.

모델은 말 그대로, 모듈화로 만들었다, 객체를 인식한다라고 해석하면 된다.

즉, **DOM은 웹브라우저가 html 페이지를 인식하는 방식**을 말한다.(트리구조)



**웹킷 동작 구조**

![img](https://camo.githubusercontent.com/fa4fdb9b5d45fec78ad6717a4f3d0099d8fe46287e2aa38a7b0500c77a48211b/68747470733a2f2f64322e6e617665722e636f6d2f636f6e74656e742f696d616765732f323031352f30362f68656c6c6f776f726c642d35393336312d332e706e67)



**게코 동작 구조**

![brouser4](https://d2.naver.com/content/images/2015/06/helloworld-59361-4.png)



웹킷과 게코가 용어를 다르게 사용하고 있지만 동작과정은 기본적으로 동일하다.

> **어태치먼트**: 웹킷이 렌더 트리를 생성하기 위해 DOM 노드와 스타일 정보를 연결하는 과정





### 파싱과 DOM 트리 구축

#### 파싱

문서 파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미

파싱 결과는 보통 문서 구조를 나타내는 노드트리이고 파싱트리 또는 문법트리라고 부른다.



**문법**

파싱은 문서에 작성된 언어 또는 형식의 규칙에 따름

파싱할 수 있는 모든 형식은 정해진 용어와 구문 규칙에 따라야한다. 이것을 `문맥 자유 문법`이라고 한다.

> 인간의 언어는 이런 모습과는 다르기 때문에 기계적으로 파싱이 불가능함



파싱은 **어휘분석**과 **구문분석**으로 구분

- 어휘분석

  자료를 유효한 토큰으로 분해하는 과정

  토큰은 유효하게 구성된 단위의 집합체(용어집)

  > 인간의 언어로 말하자면 사전에 등장하는 모든 단어에 해당

- 구문분석

  언어의 구문 규칙을 적용하는 과정



**파서가 하는 일**

1. 자료를 유효한 토큰으로 분해하는 어휘 분석기/토큰 변환기 (공백과 줄바꿈 같은 의미없는 문자를 제거)
2. 구문 규칙에 따라 문서 구조를 분석함으로써 파싱 트리를 생성하는 파서

![brouser6](https://d2.naver.com/content/images/2015/06/helloworld-59361-6.png)

파싱 과정은 반복된다.

- 어휘 분석기로부터 새 토큰을 받아서 구문규칙과 일치하는지 확인
- 규칙이 맞으면 코튼에 해당하는 노드가 파싱트리에 추가, 또 다른 토큰을 요청
- 그렇지 않으면 토큰을 내부적으로 저장하고 토큰과 일치하는 규칙이 발견될 때까지 요청, 맞는 규칙이 없을 경우 예외로 처리하는데 이것은 문서가 유효하지 않고 구문 오류를 포함하고 있다는 의미



**변환**

파싱은 보통 문서를 다른 양식으로 변환하는데 컴파일이 하나의 예

소스코드를 기계 코드로 만드는 컴파일러는 파싱 트리 생성 후 이를 기계 코드 문서로 변환한다.

![brouser7](https://d2.naver.com/content/images/2015/06/helloworld-59361-7.png)



보통 이런 파서를 생성하는 것은 문법에 대한 규칙 부여 등 최적화하기 힘드므로, 자동으로 생성해주는 `파서생성기`를 많이 사용한다.

> 웹킷은 플렉스(flex)나 바이슨(bison)을 이용하여 유용하게 파싱이 가능

우리가 head 태그를 실수로 빼먹어도 파서가 돌면서 오류를 수정해줌(head 엘리먼트 객체를 암묵적으로 만들어준다.)

결국 이 파싱 과정을 거치면서 서버로부터 받은 문서를 브라우저가 이해하고 쉽게 사용할 수 있는 DOM 트리구조로 변환시켜 주는 것이다.



https://d2.naver.com/helloworld/59361 -> 자세히 읽어보기





출처: https://github.com/gyoogle/tech-interview-for-developer/blob/master/Web/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%20%EB%8F%99%EC%9E%91%20%EB%B0%A9%EB%B2%95.md https://d2.naver.com/helloworld/59361