<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-09-21T12:33:29+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">개발일기</title><subtitle>개발일기</subtitle><author><name>Doyeon</name><email>doyeonkim.dyk@gmail.com</email></author><entry><title type="html">[TIL] `:root` 가상 선택자와 CSS 변수</title><link href="http://localhost:4000/til/pseudo-selector-css-variable/" rel="alternate" type="text/html" title="[TIL] `:root` 가상 선택자와 CSS 변수" /><published>2021-09-20T00:00:00+00:00</published><updated>2021-09-20T00:00:00+00:00</updated><id>http://localhost:4000/til/pseudo-selector-css-variable</id><content type="html" xml:base="http://localhost:4000/til/pseudo-selector-css-variable/">&lt;h2 id=&quot;root&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:root&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;가상 클래스 중 하나로 문서 트리의 루트 요소를 선택한다. 모든 HTML 문서의 루트 요소는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 이므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;html&lt;/code&gt; 선택자와 동일한 역할을 한다. 하지만 동시에 사용할 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:root&lt;/code&gt;의 &lt;a href=&quot;https://www.notion.so/df311992f2e94bafb201026873ab2f8e&quot;&gt;명시도&lt;/a&gt;가 더 낮기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;html&lt;/code&gt; 선택자가 적용된다.
css에서 사용할 변수를 선언할 때 많이 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;1-가상-선택자&quot;&gt;1. 가상 선택자&lt;/h2&gt;

&lt;h3 id=&quot;가상-클래스&quot;&gt;가상 클래스&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;선택한 요소가 &lt;strong&gt;특별한 상태&lt;/strong&gt;일 때를 위해 사용하는 선택자&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:hover&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:focus&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:active&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:visited&lt;/code&gt; 등 여러가지가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;가상-요소&quot;&gt;가상 요소&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;선택한 요소의 &lt;strong&gt;일부분&lt;/strong&gt;만 사용하기 위한 선택자&lt;/li&gt;
  &lt;li&gt;가상 클래스와 가상 요소를 구분하기 위해 CSS3부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::&lt;/code&gt; 를 도입했다. 하지만 브라우저는 이전 버전을 지원하기 때문에 CSS2의 문법인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&lt;/code&gt; 도 지원한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::first-line&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::first-letter&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::before&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::after&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;CSS로 생성한 콘텐츠는 DOM이 포함하지 않고 접근성 트리에도 들어가지 않는다. 콘텐츠가 포함한 정보가 페이지의 목적을 이해하는데 중요하다면 문서로 포함시키는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::before&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::after&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;선택한 요소의 첫 자식, 맨 마지막 자식을 선택한다&lt;/li&gt;
      &lt;li&gt;보통 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[content](https://developer.mozilla.org/ko/docs/Web/CSS/content)&lt;/code&gt; 속성과 함께 짝지어, 요소에 장식용 콘텐츠를 추가할 때 사용한다.&lt;/li&gt;
      &lt;li&gt;기본 값은 인라인이다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;conent&lt;/code&gt; 속성&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;normal&lt;/li&gt;
          &lt;li&gt;string&lt;/li&gt;
          &lt;li&gt;image&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;counter&lt;/p&gt;

            &lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;h3&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;::before&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;counter-increment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&quot;Section &quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&quot;: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;none&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;attr&lt;/code&gt; 속성을 사용할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-css-변수&quot;&gt;2. CSS 변수&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;CSS 작성자가 정의하는 개체&lt;/li&gt;
  &lt;li&gt;문서 전반적으로 재사용할 값을 담는데 사용한다.&lt;/li&gt;
  &lt;li&gt;전용 표기법을 이용해서 담고 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&lt;/code&gt; 으로 시작하는 이름)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var()&lt;/code&gt; 함수를 사용해 접근할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;css-변수의-장점&quot;&gt;css 변수의 장점&lt;/h3&gt;

&lt;p&gt;CSS를 작성하다 보면 종종 같은 값을 반복해서 사용해야 하는 경우가 많다. 웹 사이트에서 사용하는 포인트 색상이 그 대표적인 예이다. 한두 곳에서 색상코드로 사용했다면 별 문제가 되지 않겠지만, 만약 수백 곳에서 색상코드를 사용했다면 문제가 발생한다. 만약 이 색상코드를 모두 수정해야하는 경우가 생겼다고 생각해보자. 상상만 해도 아찔하다.&lt;/p&gt;

&lt;p&gt;이럴 때 사용하는 것이 CSS 변수이다. 값을 한군데에 저장해놓고 참조하는 방식으로 사용하면 &lt;strong&gt;값을 수정해야하는 상황이 발생하더라도 한군데에 저장된 값만 수정하면 되므로 편리하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;또, 사용자 지정 이름으로 사용하기 때문에 &lt;strong&gt;어디에 사용하는 값인지 이해하기 쉽다&lt;/strong&gt;는 장점도 있다.&lt;/p&gt;

&lt;h3 id=&quot;선언-방법&quot;&gt;선언 방법&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&lt;/code&gt; 로 시작하는 속성 이름과 함께, 유효한 CSS 값이라면 어떤 값이든 지정하여 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;부모 요소의 변수만 사용할 수 있기 때문에 전역에서 사용할 경우에는 흔히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:root&lt;/code&gt; 가상 선택자에 선언하여 HTML 문서 어디서든 접근할 수 있도록 한다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;:root&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;py&quot;&gt;--main-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;py&quot;&gt;--Main-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;yellow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;대소문자를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;구분한다.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;사용-방법&quot;&gt;사용 방법&lt;/h3&gt;

&lt;p&gt;사용하야 할 상황에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var()&lt;/code&gt; 함수를 사용하고 괄호 내에 변수를 입력해준다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;--main-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;**var(&amp;lt;custom-property-name&amp;gt;, &amp;lt;declaration-value&amp;gt;)**&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;첫 번째 인자로는 사용자 지정 속성이름을 입력한다.&lt;/li&gt;
  &lt;li&gt;두 번째 인자로는 첫번째 인자로 들어간 속성이 정의되지 않았을 경우 적용할 값이 들어간다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;중첩하여 사용하는 것도 가능하다.&lt;/p&gt;

    &lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--main-color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--sub-color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--main-color&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;와&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--sub-color&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;가&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;지정되지&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;않았을&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;경우&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;red를&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;적용&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;주의점&quot;&gt;주의점&lt;/h3&gt;

&lt;p&gt;브라우저는 변수에 저장된 값들이 어디에 사용될지 모르기 때문에 거의 모든 값을 유효한 것으로 간주한다. 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var()&lt;/code&gt; 함수를 통해진 값이 유효하지 않은 문맥에서 사용될 수 있다.&lt;/p&gt;

&lt;p&gt;브라우저는 유효하지 않은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var()&lt;/code&gt; 구문을 만나게 된다면, 그 속성의 초기값이나 상속된 값을 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;내일 새벽에 비온대요&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;:root&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;py&quot;&gt;--text-weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;font-weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;700&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;font-weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;--text-weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예시를 브라우저가 읽을 때 브라우저는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--text-weight&lt;/code&gt;의 값을 대체하지만, red는 font-weight에 유효한 값이 아니므로 적용하지 못한다. 그리고 두 단계를 통해서 이 상황을 처리한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;font-weight 속성이 상속되었는지를 확인&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;이 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 가 font-weigth 속성과 관련된 부모 엘리먼트가 없다. 그러면 다음 단계로 넘어간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;값을 default initial value로 처리한다. (초기 설정 기본값)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;이 경우 font-weight의 기본값인 400으로 처리된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;⚠️ &lt;strong&gt;전에 선언된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;div&lt;/code&gt; 는 적용되지 않는다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만일 사용자가 변수 없이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;font-weight: red&lt;/code&gt; 라고 입력했을 경우에 발생된 문법 에러일 경우에 전에 지정된 선언이 사용된다.&lt;/p&gt;

&lt;h3 id=&quot;javascript에서-사용하기&quot;&gt;JavaScript에서 사용하기&lt;/h3&gt;

&lt;p&gt;속성을 사용하는 것과 같다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.style.setPropertoy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&quot;--text-weight&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;700&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/CSS/:root&quot;&gt;:root&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/CSS/Using_CSS_custom_properties&quot;&gt;사용자 지정 CSS 속성 사용하기 (변수)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-classes&quot;&gt;의사 클래스&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/CSS/::before&quot;&gt;::before(:before)&lt;/a&gt; / &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/CSS/::after&quot;&gt;::after (:after)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Lists_and_Counters/Using_CSS_counters&quot;&gt;CSS 카운터 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Doyeon</name><email>doyeonkim.dyk@gmail.com</email></author><category term="[&quot;TIL&quot;]" /><category term="TIL" /><category term="CSS" /></entry><entry><title type="html">[TIL] `withRouter` 정리</title><link href="http://localhost:4000/til/day18/" rel="alternate" type="text/html" title="[TIL] `withRouter` 정리" /><published>2021-09-16T00:00:00+00:00</published><updated>2021-09-16T00:00:00+00:00</updated><id>http://localhost:4000/til/day18</id><content type="html" xml:base="http://localhost:4000/til/day18/">&lt;p&gt;리액트 앱에서 컴포넌트를 라우트로 만들면 라우트가 history api에 접근할 수 있게 되며 각각 Route에 props로 match, location, history라는 객체를 전달하게 된다. Route가 아닌 컴포넌트들은 따로 처리를 해주어야 이 객체를 전달받을 수 있는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withRouter&lt;/code&gt; 를 객체를 전달받고 싶은 컴포넌트에 사용해주면 그 컴포넌트도 Route처럼 history api를 사용할 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;withrouter&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withRouter&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;라우트가 아닌 컴포넌트에서 라우터에서 사용하는 객체(location, match, history)를 사용하게 해주는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HOC&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&quot;고차컴포넌트hoc-higher-order-component&quot;&gt;고차컴포넌트(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HOC&lt;/code&gt;, Higher Order Component)&lt;/h3&gt;

&lt;p&gt;코드를 작성하다보면 자주 작성하게 되는 코드들이 있다. 우리는 보통 이것들을 함수화해서 필요할 때마다 재사용하곤 한다. 컴포넌트도 비슷한 개념이다. 반복해서 사용되는 UI가 있으면 우리는 컴포넌트로 만들어 재사용한다. 그런데 이 컴포넌트 안에서도 반복해서 사용되는 코드가 나타날 수 있다.&lt;/p&gt;

&lt;p&gt;리액트 컴포넌트에서는 이렇게 반복되는 코드들을 HOC를 만들어서 해결한다.&lt;/p&gt;

&lt;p&gt;주로 HOC의 이름을 만들 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with___&lt;/code&gt; 의 형식으로 짓는다.&lt;/p&gt;

&lt;h3 id=&quot;hoc-동작-원리&quot;&gt;HOC 동작 원리&lt;/h3&gt;

&lt;p&gt;파라미터로 컴포넌트를 받아오고, 함수 내부에서 새 컴포넌트를 만든 다음에 새로 만든 컴포넌트 안에서 파라미터로 받아온 컴포넌트를 렌더링한다. 그리고 자신이 받아온 props들은 그대로 파라미터로 받아온 컴포넌트에게 주입해주고, 필요에 따라 추가의 props도 넣어줍니다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// withRequest.js&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;react&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;withRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;WrappedComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;WrappedComponent&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&amp;gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;withRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 보면, 함수에서 또 다른 함수를 리턴하도록 되어있다. 이렇게 만든 이유는 나중에 여러 개의 HOC를 합쳐서 사용하게 될 때 더욱 편하게 사용하기 위함이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compose&lt;/code&gt; 같은 함수를 통해서 호출을 간소화시킬 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;withrouter-사용하기&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withRouter&lt;/code&gt; 사용하기&lt;/h3&gt;

&lt;p&gt;위의 HOC 동작 원리를 가지고 따져보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withRouter&lt;/code&gt;는 컴포넌트를 파라미터로 받아, 함수 내부에서 새로운 컴포넌트를 만든 다음, 원래 컴포넌트가 가지고 있던 props와 Route가 사용하는 객체를 함쳐서 props로 주입시켜준 후에, 새로 만들어진 컴포넌트를 리턴해주는 HOC인 것이다.&lt;/p&gt;

&lt;p&gt;간단하게 파라미터로 전달받은 컴포넌트에 라우트가 사용하는 객체를 넣어서 반환해주는 HOC라고 생각해도 될 것 같다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// App.js&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;react&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Route&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;react-router-dom&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Page&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;./Page&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Route&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;exact&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Home&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ShowPageInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 Page 컴포넌트는 App 컴포넌트에서 볼 수 있듯이 라우트가 아닌 컴포넌트이다. 하지만 아래처럼 withRouter를 사용해주면 라우트에서만 사용할 수 있던 match, location 같은 객체를 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Page.js&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;react&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;withRouter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;react-router-dom&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;withRouter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;현재 위치: &lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pathname&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;history&quot;&gt;history&lt;/h3&gt;

&lt;p&gt;스택(stack)에 현재까지 이동한 url 경로들이 담겨있는 형태로 주소를 임의로 변경하거나 되돌아갈 수 있도록 해준다. 브라우저의 history와 유사하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;length : [number] 전체 history 스택의 길이&lt;/li&gt;
  &lt;li&gt;action : [string] 최근에 수행된 action (PUSH, REPLACE, POP)
    &lt;ul&gt;
      &lt;li&gt;PUSH : 경로를 저장하면서 이동&lt;/li&gt;
      &lt;li&gt;REPLACE : 경로를 저장하지 않으면서 이동&lt;/li&gt;
      &lt;li&gt;POP : (?)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;location : [JSON object] 최근 경로 정보&lt;/li&gt;
  &lt;li&gt;push(path, [state]) : [function] 새로운 경로를 history 스택으로 푸시하여 페이지를 이동&lt;/li&gt;
  &lt;li&gt;replace(path, [state]) : [function] 최근 경로를 history 스택에서 교체하여 페이지를 이동, 교체하기 때문에 push와 달리 다시 돌아올 수 없음&lt;/li&gt;
  &lt;li&gt;go(n) : [function] history 스택의 포인터를 n번째로 이동&lt;/li&gt;
  &lt;li&gt;goBack() : [function] 이전 페이지로 이동&lt;/li&gt;
  &lt;li&gt;goForward() : [function] 앞 페이지로 이동&lt;/li&gt;
  &lt;li&gt;block(prompt) : [function] history 스택의 PUSH/POP 동작을 제어&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;match&quot;&gt;match&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Route path&amp;gt;&lt;/code&gt;와 URL의 매칭에 대한 정보가 담겨져 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;path&lt;/strong&gt; : [string] 라우터에 정의된 path&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;url&lt;/strong&gt; : [string] 실제 클라이언트로부터 요청된 url path&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;isExact&lt;/strong&gt; : [boolean] true일 경우 전체 경로가 완전히 매칭된 경우에만 요청을 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;params&lt;/strong&gt; : [JSON object] url path로 전달된 파라미터 객체&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;location&quot;&gt;location&lt;/h3&gt;

&lt;p&gt;현재 페이지의 정보를 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;pathname&lt;/strong&gt; : [string] 현재 페이지의 경로명&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;search&lt;/strong&gt; : [string] 현재 페이지의 query string&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;hash&lt;/strong&gt; : [string] 현재 페이지의 hash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참조 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://react-router.vlpt.us/1/05.html&quot;&gt;1-5. withRouter&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.reactjs.org/docs/higher-order-components.html&quot;&gt;고차컴포넌트&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;[React&lt;/td&gt;
          &lt;td&gt;Router : match, location, history](https://gongbu-ing.tistory.com/45)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velopert.com/3537&quot;&gt;컴포넌트에 날개를 달아줘, 리액트 Higher-order Component (HoC)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Doyeon</name><email>doyeonkim.dyk@gmail.com</email></author><category term="[&quot;TIL&quot;]" /><category term="codestates" /><category term="TIL" /><category term="React" /></entry><entry><title type="html">[TIL] React의 특징</title><link href="http://localhost:4000/til/day17-1/" rel="alternate" type="text/html" title="[TIL] React의 특징" /><published>2021-09-15T00:00:00+00:00</published><updated>2021-09-15T00:00:00+00:00</updated><id>http://localhost:4000/til/day17-1</id><content type="html" xml:base="http://localhost:4000/til/day17-1/">&lt;h2 id=&quot;1-선언형&quot;&gt;1. 선언형&lt;/h2&gt;

&lt;p&gt;선언형 프로그래밍이란 &lt;strong&gt;무엇을&lt;/strong&gt;에 집중한 방식으로 코드가 어떻게 동작하는지 자세히 알지 못해도 무엇을 하는 코드인지 알 수 있다. 다시 말해서 어떻게 동작하는지에 대한 부분은 추상화된 방식이라고 할 수 있다. 리액트는 JSX를 사용하여 HTML, JS, CSS를 한 파일에서 작성하는 선언형 프로그래밍을 지향한다.&lt;/p&gt;

&lt;h2 id=&quot;2-컴포넌트-기반&quot;&gt;2. 컴포넌트 기반&lt;/h2&gt;

&lt;p&gt;하나의 기능을 구현하기 위해 여러 종류의 코드를 묶어두는 컴포넌트를 기반으로 한다. 개념적으로 컴포넌트는 JavaScript의 함수와 유사한데, 컴포넌트 기반이라는 것은 부품을 작은 단위로 각각 개발하고 화면에 보여줄 때, 필요한 부품들을 가져다가 조립해서 보여주는 것을 말한다.
개발할 때는 번거로울 수 있으나, 컴포넌트를 분리하면 서로 독립적이고 재사용성이 좋기 때문에 기능 자체에만 집중하여 개발할 수 있을 뿐더러 유지보수에 용이하다.&lt;/p&gt;

&lt;h2 id=&quot;3-범용성&quot;&gt;3. 범용성&lt;/h2&gt;

&lt;p&gt;자바스크립트 프로젝트 어디서든 유연하게 사용할 수 있다. 라이브러리이기 때문에 한 부분만 리액트를 적용하는 것이 가능하다.
또, 페이스북에서 개발하고 관리하고 있기 때문에 안정적이고 현재 가장 유명하다. 리액트 네이티브로는 모바일 개발도 할 수 있다.&lt;/p&gt;

&lt;p&gt;출처 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;코드스테이츠 자료&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.reactjs.org/docs/components-and-props.html&quot;&gt;Component와 Props&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kimdoyeonn.github.io/til/day16-1/&quot;&gt;선언형 프로그래밍 vs 절차형 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Doyeon</name><email>doyeonkim.dyk@gmail.com</email></author><category term="[&quot;TIL&quot;]" /><category term="codestates" /><category term="TIL" /></entry><entry><title type="html">[TIL] 선언형 프로그래밍 vs 절차형 프로그래밍</title><link href="http://localhost:4000/til/day16-1/" rel="alternate" type="text/html" title="[TIL] 선언형 프로그래밍 vs 절차형 프로그래밍" /><published>2021-09-14T00:00:00+00:00</published><updated>2021-09-14T00:00:00+00:00</updated><id>http://localhost:4000/til/day16-1</id><content type="html" xml:base="http://localhost:4000/til/day16-1/">&lt;p&gt;절차형 프로그래밍은 무엇을 &lt;strong&gt;어떻게&lt;/strong&gt; 할 것인가에 가깝고, 선언형 프로그래밍은 &lt;strong&gt;무엇을&lt;/strong&gt; 할 것인가와 가깝다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배열의 합을 구하는 로직을 작성한다고 해보자 절차형으로 작성한다면 위와 같은 방식으로 작성할 수 있을 것이다. 배열을 가지고 어떻게 해서 합을 구할 것인지가 구체적으로 드러난 코드이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;똑같이 배열의 합을 구하는 로직을 선언형 프로그래밍으로 작성하면 위와 같은 방식으로 작성할 수 있다. reduce 메소드를 이용하여 배열의 합을 구하는 코드이고, 절차형으로 작성한 코드에 비하면 상당부분이 생략된 것을 알 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;절차형 프로그래밍은 &lt;strong&gt;어떻게&lt;/strong&gt;에 초점이 맞춰진 방식이고, 선언형 프로그래밍은 &lt;strong&gt;무엇을&lt;/strong&gt;에 초점이 맞춰진 방식이다. 선언형 프로그래밍 방식에서는 &lt;strong&gt;어떻게&lt;/strong&gt;의 부분을 누군가 할 수 있다는 가정하에 &lt;strong&gt;무엇을&lt;/strong&gt; 부분에 초점을 맞추는 것이기 때문에 선언형 프로그래밍이 제대로 동작하기 위해서는 절차형으로 작성된 &lt;strong&gt;어떻게&lt;/strong&gt;에 대한 부분이 추상화 되어 있어야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;출처 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://boxfoxs.tistory.com/430&quot;&gt;명령형 프로그래밍 VS 선언형 프로그래밍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dzone.com/articles/imperative-vs-declarative-javascript&quot;&gt;Imperative vs. Declarative JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Doyeon</name><email>doyeonkim.dyk@gmail.com</email></author><category term="[&quot;TIL&quot;]" /><category term="codestates" /><category term="TIL" /></entry><entry><title type="html">[TIL] 고차함수</title><link href="http://localhost:4000/til/day16/" rel="alternate" type="text/html" title="[TIL] 고차함수" /><published>2021-09-14T00:00:00+00:00</published><updated>2021-09-14T00:00:00+00:00</updated><id>http://localhost:4000/til/day16</id><content type="html" xml:base="http://localhost:4000/til/day16/">&lt;h2 id=&quot;일급함수first-class-citizen&quot;&gt;일급함수(first-class citizen)&lt;/h2&gt;

&lt;p&gt;함수를 다른 변수들과 동일하게 다루는 언어를 일급함수를 가진 언어라고 표현한다. 함수를 다른 변수들과 동일하게 다룬다는 의미는,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;함수를 변수에 할당할 수 있다.&lt;/li&gt;
  &lt;li&gt;함수를 인자로 전달할 수 있다.&lt;/li&gt;
  &lt;li&gt;함수를 결과로서 반환할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;는 것을 의미한다. 자바스크립트는 일급함수를 가진 언어 중에 하나이다.&lt;/p&gt;

&lt;h2 id=&quot;고차함수higher-order-function&quot;&gt;고차함수(higher-order function)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;함수를 인자로 받거나, 함수를 리턴하는 함수&lt;/strong&gt;를 말한다.&lt;/p&gt;

&lt;p&gt;이 중 함수를 리턴하는 함수를 이 함수를 고안한 논리학자 하스켈 커리의 이름을 따서 커리함수라고 부르기도 하는데, 정확하게 구분하자면 커리함수도 고차함수에 포함된다.&lt;/p&gt;

&lt;h2 id=&quot;커링과-클로저의-차이&quot;&gt;커링과 클로저의 차이&lt;/h2&gt;

&lt;p&gt;클로저는 외부 함수의 변수에 접근할 수 있는 내부함수, 또는 이런한 작동 원리를 나타내는 용어이다.
그리고 커링은 함수에 n개의 인자를 받는 대신, n개의 클로저 함수를 만들어 각각 인자를 받게 만드는 방법이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;multiply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;multiply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3*5*7&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;multiply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3*5*8&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;multiply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3*2*1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 작성하면 첫번째 인자가 3으로 모두 같아도, 첫번째, 두번째 케이스에서 두번째 인자가 모두 5로 같아도 모든 인자를 직접 지정해주어야 한다. 이 때 컬링을 사용하여 특정 인자를 재사용 할 수 있게 만들 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;multiply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;multiply3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;multiply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;multiply3And5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;multiply3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;multiply3And2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;multiply3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;multiply3And5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;multiply3And5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;multiply3And2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;컬링과 클로저가 다른 것이 아니라 클로저의 특성을 이용하여 값을 다루는 방법 중에 하나가 컬링 인 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;참고&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@nittre/JavaScript-Closure%EC%99%80-Currying&quot;&gt;클로저(Closure)와 커링(Currying) 간단하게 정리&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;코드스테이츠 자료&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Doyeon</name><email>doyeonkim.dyk@gmail.com</email></author><category term="[&quot;TIL&quot;]" /><category term="codestates" /><category term="TIL" /></entry><entry><title type="html">[TIL] 이벤트 객체</title><link href="http://localhost:4000/til/day15/" rel="alternate" type="text/html" title="[TIL] 이벤트 객체" /><published>2021-09-13T00:00:00+00:00</published><updated>2021-09-13T00:00:00+00:00</updated><id>http://localhost:4000/til/day15</id><content type="html" xml:base="http://localhost:4000/til/day15/">&lt;h2 id=&quot;이벤트란&quot;&gt;이벤트란?&lt;/h2&gt;

&lt;p&gt;사용자가 웹 페이지를 사용하면서 발생하는 상호작용을 말한다. 예로는 클릭, 스크롤, 마우스올림, 키눌림, 키떨어짐 등이 있다.&lt;/p&gt;

&lt;h2 id=&quot;이벤트-객체란&quot;&gt;이벤트 객체란?&lt;/h2&gt;

&lt;p&gt;사용자에 의해 웹 페이지에서 이벤트가 발생하면 등록된 이벤트 리스너가 호출된다. 이 때 이벤트 리스너가 이벤트에 대한 정보가 담긴 객체를 전달받는데, 이 객체가 이벤트 객체이다.
이벤트 객체는 이벤트 핸들러 함수의 첫번째 인자로 전달되고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event&lt;/code&gt; 라는 이름으로 사용한다.
이벤트 객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt; 속성과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentTarget&lt;/code&gt; 속성에 이벤트가 발생한 엘리먼트에 대한 정보가 담겨 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt; : 이벤트 버블링의 가장 하위 요소를 나타낸다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentTarget&lt;/code&gt; : 이벤트 핸들러가 등록된 요소 자체를 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;때문에 보통은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentTarget&lt;/code&gt;을 사용하는 것이 편하다.&lt;/p&gt;

&lt;h2 id=&quot;이벤트의-종류&quot;&gt;이벤트의 종류&lt;/h2&gt;

&lt;p&gt;여러가지가 있는데, 대표적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onclick&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onscroll&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onkeyup&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onmouseover&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onsubmit&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onchange&lt;/code&gt; 등이 있다. 보통은 이름만으로 어떤 이벤트인지 짐작이 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onsubmit&lt;/code&gt; : 현재 창에서 폼을 전송하는 이벤트를 다루는 이벤트 핸들러&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onchange&lt;/code&gt; : 값의 커밋 이벤트를 다루는 이벤트 핸들러이다. input, select, textarea의 값 커밋을 확인할 때 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;이벤트-등록-방법&quot;&gt;이벤트 등록 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onclick&lt;/code&gt; 같은 이벤트 핸들러에 직접 할당하는 방법&lt;/p&gt;

    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addEventListener&lt;/code&gt;를 사용하여 이벤트 핸들러를 등록하는 방법&lt;/p&gt;

    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;동작은 같지만 여러 개의 핸들러를 할당하려고 할 때 문제가 생긴다. 직접할당하는 방법은 여러 개를 할당할 경우 이전에 할당된 이벤트 핸들러가 덮어씌워지기 때문에 최근에 할당한 핸들러만 동작하게 된다.
그에 반해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addEventListener&lt;/code&gt;로 등록된 핸들러는 여러 개를 등록하더라도 덮어씌워지지 않고 모두 정상 동작한다.&lt;/p&gt;

&lt;h2 id=&quot;이벤트-막기&quot;&gt;이벤트 막기&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event.preventDefault&lt;/code&gt;
브라우저 구현에 의해 처리되는 기존의 동작들이 발생하지 않도록 한다. 예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;submit&lt;/code&gt; 이벤트가 발생하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;input&lt;/code&gt; 버튼의 이벤트 핸들러에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event.preventDefault&lt;/code&gt;를 넣으면 submit이 동작하지 않아 값이 전달되지 않고 페이지도 이동되지 않는다.&lt;/p&gt;</content><author><name>Doyeon</name><email>doyeonkim.dyk@gmail.com</email></author><category term="[&quot;TIL&quot;]" /><category term="codestates" /><category term="TIL" /></entry><entry><title type="html">[TIL] DOM</title><link href="http://localhost:4000/til/day14/" rel="alternate" type="text/html" title="[TIL] DOM" /><published>2021-09-10T00:00:00+00:00</published><updated>2021-09-10T00:00:00+00:00</updated><id>http://localhost:4000/til/day14</id><content type="html" xml:base="http://localhost:4000/til/day14/">&lt;h3 id=&quot;dom의-개념&quot;&gt;DOM의 개념&lt;/h3&gt;

&lt;p&gt;Document Object Model의 약자로 HTML 요소를 Object처럼 조작할 수 있는 Model을 말한다. 문서 내의 모든 요소를 정의하고, 접근할 수 있는 방법을 제공한다. DOM이라는 구조를 기반으로, JavaScript로 프로그램을 작성하여 HTML을 조작한다.&lt;/p&gt;

&lt;p&gt;BOM(Browser Object Model)이 DOM과 함께 통칭되기도 한다. BOM은 웹 브라우저와 관련된 객체의 집합으로 window 객체를 통해 브라우저에 접근한다. 정확히는 자바스크립트가 아닌 웹 브라우저가 제공하는 기능이다.&lt;/p&gt;

&lt;h3 id=&quot;dom의-구조&quot;&gt;DOM의 구조&lt;/h3&gt;

&lt;p&gt;여러 구성요소가 부모-자식 관계를 가지고 있는 노드트리구조이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTML과 DOM의 차이&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;브라우저는 사용자가 요청해서 받아온 HTML 문서를 파싱하여 DOM 트리를 그리고, CSS파일을 파싱하여 이를 결합한 후 렌더링하는 작업을 통해 우리가 보고있는 화면을 그린다.&lt;/p&gt;

&lt;p&gt;HTML은 단순히 규칙에 따라 정해진 태그, 속성값으로 이루어진 언어이며, DOM은 브라우저가 HTML을 파싱한 후 생성되는 객체 모델로, document에 접근가능한 API이다.&lt;/p&gt;

&lt;p&gt;DOM은 document 객체를 통해 HTML(root document)에 접근한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTML에서 JS 파일을 불러올 때 주의할 점&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;script 태그는 &amp;lt;/body&amp;gt; 직전에 작성해야 한다.&lt;/p&gt;

&lt;p&gt;브라우저가 HTML을 파싱할 때, 위에서 아래로 읽는데, 중간에 script를 만나면 HTML을 읽는 것을 잠시 멈추고 script를 해석한다. 이 때 script를 읽다가 아직 해석되지 않은 HTML 태그를 만나게 된다면 의도하지 않은 오류가 발생하게 될 수도 있다. 때문에 HTML 문서가 다 파싱된 후인 &amp;lt;/body&amp;gt; 태그 직전에 작성해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DOM과 JavaScript의 차이&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTML은 프로그래밍을 위해서 만들어진 언어가 아니기 때문에 조건문, 반복문을 사용할 수 없고, 정보를 저장하기에도 적합한 언어가 아니다. 그래서 자바스크립트라는 프로그래밍 언어와 DOM을 활용하여 HTML에 접근하고 조작한다.&lt;/p&gt;

&lt;p&gt;DOM을 활용할 수 있는 언어는 JavaScript만 있는 것은 아니지만 JavaScript가 가장 오래되고 안정적인 방법이다. 또, HTML 구조가 JavaScript의 객체 구조와 같은 트리구조라서 자바스크립트의 DOM이 브라우저에 적합하다.&lt;/p&gt;

&lt;h3 id=&quot;crud&quot;&gt;CRUD&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;CREATE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;createElement&lt;/code&gt; : 새로운 엘리먼트를 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;READ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;querySelector&lt;/code&gt; : 조건에 맞는 첫번째 엘리먼트를 조회한다.&lt;/p&gt;

&lt;p&gt;document 객체의 자식 메서드이지만, element 객체의 자식 메서드이기도 하기 때문에 document 객체뿐만 아니라 모든 엘리먼트에서 사용할 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;querySelectorAll&lt;/code&gt;도 마찬가지이다.&lt;/p&gt;

&lt;p&gt;여러가지 셀렉터들을 조합하여 복잡한 조회도 수행할 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;querySelectorAll&lt;/code&gt;도 마찬가지이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;querySelectorAll&lt;/code&gt; : 조건에 맞는 모든 엘리먼트를 조회&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;children&lt;/code&gt; : 엘리먼트의 자식 엘리먼트 조회&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parentNode&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parentElement&lt;/code&gt; : 엘리먼트의 부모 엘리먼트 조회&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;textContent&lt;/code&gt; : 태그 사이의 문자열을 수정할 때 사용&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; id 속성을 수정할 때 사용&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;classList&lt;/code&gt; : 엘리먼트의 class를 조회, 삭제, 수정, 추가 등 관리할 때 사용한다. add, remove를 사용하여 원하는 동작을 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setAttribute&lt;/code&gt; : 속성을 수정할 때 사용한다. 첫번째 인자로는 속성이름, 두번째 인자로는 값을 넣고 실행한다. 어떤 태그를 어떤 값으로 변경하려 하는지 직관적으로 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DELETE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove&lt;/code&gt; : 삭제하려는 엘리먼트에 사용하면 엘리먼트가 삭제된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;removeChild&lt;/code&gt; : 삭제하려는 엘리먼트의 부모노드에서 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innerHTML = &quot;&quot;&lt;/code&gt; : 자식의 모든 엘리머트를 삭제한다. 사용에 간단하지만 XSS Attack의 위험이 있으므로 사용하지 않는 것이 좋다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;textContent = &quot;&quot;&lt;/code&gt; : 모든 자식 엘리먼트를 삭제한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;XSS Attack : script 태그를 활용하여 강제로 해커가 원하는 스크립트를 실행시키는 공격이다. HTML 태그를 직접 삽입하여 실행하는 형태의 메소드(ex. innerHTML)는 항상 XSS Attack의 위험을 가지고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;APPEND&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;appendChild&lt;/code&gt; : append 메서드와는 다르게 Node 객체만 받을 수 있고, 한번에 하나의 자식 요소만 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;append&lt;/code&gt; : append 메서드를 활용하면 노드 객체(Node object)나 DOMString(text)를 사용할 수 있다. 또한 한번에 여러 개의 자식 요소를 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insertBefore&lt;/code&gt; : 원하는 위치에 노드를 넣을 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innerHTML&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;textContent&lt;/code&gt;의 차이&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innerHTML&lt;/code&gt;은 이름 그대로 HTML을 반환한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;textContent&lt;/code&gt;는 노드 내의 텍스트를 반환한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;textContent&lt;/code&gt;는 HTML로 분석할 필요가 없다는 점에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innerHTML&lt;/code&gt;보다 성능이 좋다. 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;textContent&lt;/code&gt;는 XSS 공격의 위험이 없다.&lt;/p&gt;</content><author><name>Doyeon</name><email>doyeonkim.dyk@gmail.com</email></author><category term="[&quot;TIL&quot;]" /><category term="codestates" /><category term="TIL" /></entry><entry><title type="html">[TIL] 호이스팅(Hoisting) &amp;amp; 얕은복사, 깊은복사</title><link href="http://localhost:4000/til/day13/" rel="alternate" type="text/html" title="[TIL] 호이스팅(Hoisting) &amp;amp; 얕은복사, 깊은복사" /><published>2021-09-09T00:00:00+00:00</published><updated>2021-09-09T00:00:00+00:00</updated><id>http://localhost:4000/til/day13</id><content type="html" xml:base="http://localhost:4000/til/day13/">&lt;h3 id=&quot;호이스팅hoisting&quot;&gt;호이스팅(Hoisting)&lt;/h3&gt;

&lt;p&gt;선언된 변수, 함수 등을 유효범위의 최상단으로 끌어올리는 것을 말한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;대상&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;var 변수 선언, 함수 선언문이 끌어올려진다.&lt;/li&gt;
  &lt;li&gt;할당이 아닌, 선언 자체만 끌어올려진다.&lt;/li&gt;
  &lt;li&gt;let, const 변수 선언, 함수 표현식은 블록 스코프가 명확하기 때문에 호이스팅이 발생하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;우선순위&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변수 선언이 함수 선언보다 높이 끌어올려진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;얕은-복사-vs-깊은-복사&quot;&gt;얕은 복사 vs 깊은 복사&lt;/h3&gt;

&lt;p&gt;얕은 복사란 객체를 복사할 때 겉의 객체는 새로 만들어져 새로운 주소를 가지지만 내부의 객체들은 기존의 객체와 동일한 주소를 갖는 것을 말한다. 때문에 내부의 객체들은 하나만 변경되더라도 원본과 복사본 모두 변경된다. 껍데기만 새로운 껍데기인 것&lt;/p&gt;

&lt;p&gt;깊은 복사의 경우 복합 객체는 물론 내부의 다른 객체들까지 재귀적으로 모두 새로운 객체로 생성된다. 때문에 완전히 다른 객체가 생성된 것과 같아서, 원본 객체를 수정한다고 하더라도 복사본 객체는 상태글 그대로 유지한다.&lt;/p&gt;</content><author><name>Doyeon</name><email>doyeonkim.dyk@gmail.com</email></author><category term="[&quot;TIL&quot;]" /><category term="codestates" /><category term="TIL" /></entry><entry><title type="html">[TIL] 클로저(Closure)란?</title><link href="http://localhost:4000/til/day12/" rel="alternate" type="text/html" title="[TIL] 클로저(Closure)란?" /><published>2021-09-08T00:00:00+00:00</published><updated>2021-09-08T00:00:00+00:00</updated><id>http://localhost:4000/til/day12</id><content type="html" xml:base="http://localhost:4000/til/day12/">&lt;h3 id=&quot;정의&quot;&gt;정의&lt;/h3&gt;

&lt;p&gt;외부 함수의 생명주기가 끝났는데도 내부 함수가 외부 함수의 변수에 접근할 수 있는 것&lt;/p&gt;

&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;내부함수는 외부함수의 변수에 접근할 수 있다.&lt;/li&gt;
  &lt;li&gt;함수를 리턴하는 함수&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;외부함수와 외부함수에 의해 리턴되는 내부함수로 이루어져 있다. 이때 외부함수는 내부함수의 변수에 접근할 수 없고 내부함수는 외부함수의 변수에 접근할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;활용&quot;&gt;활용&lt;/h3&gt;

&lt;p&gt;일반적인 경우는 함수 실행이 끝나면 내부의 지역변수들은 사용할 수 없다. 하지만 클로저는 외부 함수의 실행이 끝나더라도 외부함수의 변수가 메모리에 남아있기 때문에 내부함수에서 사용할 수 있다. (어휘적 환경을 메모리에 저장하기 때문에)&lt;/p&gt;

&lt;p&gt;이 특징을 이용해서 외부에서 접근할 수 없도록 값을 숨기는데 사용할 수 있고, 특정 데이터를 스코프 안에 가둬둔 채로 사용할 수도 있고, 캡슐화 시켜서 값을 직접 조작하지 않고 간접적으로 조작할 수 있도록 만들 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;makeCounter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;increase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;decrease&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;getCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같은 코드를 모듈화라고 한다. 객체를 반환하는 함수인데, 클로저를 사용하여 count 변수의 값을 간접적으로 조작할 수 있다.&lt;/p&gt;

&lt;p&gt;코드를 모듈화 하면 재사용성이 높아지고 함수를 독립적인 부품처럼 사용할 수 있게 된다. 클로저를 사용하면 데이터와 메소드를 같이 묶어서 다룰 수 있기 때문에 모듈화에 유리하다.&lt;/p&gt;</content><author><name>Doyeon</name><email>doyeonkim.dyk@gmail.com</email></author><category term="[&quot;TIL&quot;]" /><category term="codestates" /><category term="TIL" /></entry><entry><title type="html">[TIL] flex 생소한 속성 정리</title><link href="http://localhost:4000/til/day11/" rel="alternate" type="text/html" title="[TIL] flex 생소한 속성 정리" /><published>2021-09-07T00:00:00+00:00</published><updated>2021-09-07T00:00:00+00:00</updated><id>http://localhost:4000/til/day11</id><content type="html" xml:base="http://localhost:4000/til/day11/">&lt;p&gt;flex에는 부모에 적용하는 속성과 자식에 적용하는 속성이 있다. 처음엔 혼란스럽고 헷갈렸는데, 쓰다보니까 편하고 쓸만한 것 같기도 하고… 아닌 것 같기도 하고… 쩃든 오늘은 css 셀렉터랑 flexbox를 공부했는데 보니까 내가 안 써본 flex 속성들이 몇 개 있길래 공부 겸 정리해보려고 한다. css 셀렉터는 써보면서 외워야 공부가 될 것 같아서 일단 간략하게 정리만 하구..&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;flex&quot;&gt;flex&lt;/h3&gt;

&lt;p&gt;flex는 display 속성의 값 중 하나로 레이아웃을 짤 때 자주 사용하는 방식 중에 하나이다. 부모 엘리먼트에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display: flex;&lt;/code&gt;를 적용하면 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;부모 엘리먼트에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flex-direction&lt;/code&gt; 속성을 사용해 주축을 정할 수 있다. 기본 값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;row&lt;/code&gt;이고, 반대는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;column&lt;/code&gt; 이 있다.&lt;/p&gt;

&lt;p&gt;방향이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;row&lt;/code&gt;일 때 부모 엘리먼트에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;justify-content&lt;/code&gt; 속성을 사용하면 수평 방향의 정렬, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;align-items&lt;/code&gt; 속성을 사용하면 수직 방향의 정렬을 정해줄 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;column&lt;/code&gt;일 때는 주축이 수직방향으로 바뀌기 때문에 반대로 적용된다.&lt;/p&gt;

&lt;p&gt;자식 엘리먼트에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flex-grow&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flex-shrink&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flex-basis&lt;/code&gt; 속성이 있고,&lt;/p&gt;

&lt;p&gt;grow는 아이템이 주축 방향으로 얼마나 늘어날지 설정하는 속성이다. 기본값은 0이고 1 이상이 되면 전체 아이템들에 적용된 grow의 합에 대한 비율로 크기가 결정된다.
shrink는 아이템이 얼마나 줄어들지 설정하는 속성이다. grow와 중첩되지 않도록 사용하는 것을 추천한다.
basis는 아이템의 기본 크기를 설정하는 속성이다. 기본값은 auto이고 이 때 grow와 함께 사용하면 아이템의 크기를 뺀 공백을 기준으로 아이템의 크기가 결정되기 때문에 값을 0으로 해줘야 원하는 비율의 레이아웃을 구현할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이제 거의 사용 안해봐서 잘 모르는 속성들~~~ 일단 부모 속성부터&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flex-wrap&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;줄 넘김을 처리하는 설정이다. 컨테이너가 더이상 아이템들을 한 줄에 담을 여유 공간이 없을 때 아이템 줄바꿈을 어떻게 할지 결정하는 속성이다.&lt;/li&gt;
  &lt;li&gt;nowrap : 기본값으로 줄넘김을 하지 않고 아이템이 밖으로 빠져나간다.&lt;/li&gt;
  &lt;li&gt;wrap : 아래로 줄을 넘긴다.&lt;/li&gt;
  &lt;li&gt;wrap-reverse : 줄을 넘기긴 하는데 위로 넘긴다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flex-flow&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;flex-direction, flex-wrap을 같이 사용할 수 있는 단축 속성이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;align-content&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flex-wrap: wrap;&lt;/code&gt;이 설정되어 있을 때, 아이템의 행이 2줄 이상이 될 수 있는데, 이 때 모든 아이템들을 같이 수직 방향으로 정렬할 수 있는 속성이다. 여러 행의 정렬을 조절한다. 값은 align-items와 동일하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;이제 자식 속성~~~&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 아이템들의 순서를 결정하는 속성이다. 숫자를 값으로 가지며 숫자가 작을 수록 우선 순위를 가진다.&lt;/li&gt;
  &lt;li&gt;화면에 보이는 순서가 바뀌는 것뿐 HTML 문서의 구조 자체가 바뀌는 것은 아니기 때문에 접근성 측면에서 생각하면 사용에 주의해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;align-self&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;아이템의 수적정렬을 결정하는 속성이다. 기본값은 auto이다.&lt;/li&gt;
  &lt;li&gt;기본값 auto만 빼면 align-items와 동일한 값을 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;속성이 적용될 때 align-items보다 우선순위를 가진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;css-selector&quot;&gt;css selector&lt;/h3&gt;

&lt;p&gt;처음엔 .이랑 #만 알면되는 줄 알았는데 알면 알수록 할 수 있는게 너무 많다 허허헣허허헣ㅎ헣허&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자식 셀렉터 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A &amp;gt; B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;자손 셀렉터 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;자식 셀렉터는 바로 아래의 자식 엘리먼트들에만 적용되고, 자손 셀렉터는 자식 엘리먼트들뿐만 아니라 그 아래의, 그 아래의…. 모든 엘리먼트들에 적용된다는 점이 차이점이다.&lt;/li&gt;
  &lt;li&gt;인접 형제 셀렉터 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A + B&lt;/code&gt; A 뒤에 있는 B&lt;/li&gt;
  &lt;li&gt;형제 셀렉터 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A ~ B&lt;/code&gt; A와 같은 단계에 있는 모든 B&lt;/li&gt;
  &lt;li&gt;요소 상태 셀렉터
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:checked&lt;/code&gt; : 체크상태일 때&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:enabled&lt;/code&gt; : 사용가능한 상태일 때&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:disabled&lt;/code&gt; : 사용 불가능한 상태일 때&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정합성 확인 셀렉터
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:valid&lt;/code&gt; : 정합성 검증에 성공한 input 요소 또는 from 요소를 선택&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:invalid&lt;/code&gt; : 정합성 실패한 input 요소 또는 form 요소를 선택&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Doyeon</name><email>doyeonkim.dyk@gmail.com</email></author><category term="[&quot;TIL&quot;]" /><category term="codestates" /><category term="TIL" /></entry></feed>