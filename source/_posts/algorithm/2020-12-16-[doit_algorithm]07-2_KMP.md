---
title: "[doit_algorithm] 07-2 KMP법"
excerpt: ""
category:
  - doit_algorithm
tags: [python, doit_algorithm]
---

참고: doit 자료구조와 함께 배우는 알고리즘 입문



#### KMP법 알아보기

브루트 포스법은 일치하지 않는 문자를 만나면 이전 단계에서 검사했던 결과를 버리고 패턴의 첫 문자부터 다시 검사를 수행합니다. 하지만 KMP법은 검사했던 결과를 버리지 않고 효율적으로 활용하는 알고리즘입니다.

>KMP법은 Knuth-Morris-Pratt법의 줄임말로 이 알고리즘을 고안한 세 명의 이름에서 따온 용어입니다.

KMP법은 텍스트와 패턴 안에서 겹치는 문자열을 찾아내 검사를 다시 시작할 위치를 구하여 패터느이 이동을 되도록이면 크게 하는 알고리즘이니다. 그런데 몇 번째 문자부터 검사를 다시 시작할지 패턴을 이동할 때마다 계산한다면 좋은 효율을 기대할 수 없습니다. 그래서 KMP법은 '몇 번째 문자부터 다시 검색할지'값을 표로 만들어서 문제를 해결합니다.



#### KMP법에서 사용하는 표 만들기

표를 작성할 때는 패턴에서 겹치는 문자열을 찾습니다. 이 과정에서도 KMP법과 같은 방법을 적용합니다. 패턴의 첫 문자가 일치하지 않으면 패턴을 오른쪽으로 1칸 밀어 첫 문자부터 검사해야 하므로 2번째 문자 이후 부분을 생각합니다. 또 패턴과 텍스트를 서로 겹치도록 맞추는 것이 아니라 패턴끼리(즉, 패턴과 패턴을) 서로 겹치도록 맞추고 검사를 시작할 곳을 계산합니다.

> p312 건너뛰기 표 이해안됨





```python
def kmp_match(txt: str, pat: str) -> int:
    """KMP법으로 문자열 검색"""
    pt = 1                          # txt를 따라가는 커서
    pp = 0                          # pat를 따라가는 커서
    skip = [0] * (len(pat) + 1)     # 건너뛰기 표

    # 건너뛰기 표 만들기
    skip[pt] = 0
    while pt != len(pat):
        if pat[pt] == pat[pp]:
            pt += 1
            pp += 1
            skip[pt] = pp
        elif pp == 0:
            pt += 1
            skip[pt] = pp
        else:
            pp = skip[pp]

    # 문자열 검색하기
    pt = pp = 0
    while pt != len(txt) and pp != len(pat):
        if txt[pt] == pat[pp]:
            pt += 1
            pp += 1
        elif pp == 0:
            pt += 1
        else:
            pp = skip[pp]

    return pt - pp if pp == len(pat) else -1
```

KMP법에서 텍스트를 스캔하는 커서 pt는 앞으로 나아갈 뿐 뒤로 되돌아오지 않습니다. 이것은 브루트 포스법에는 없는 특징입니다. 그러나 이 알고리즘은 복잡할 뿐 보이어무어법보다 성능 면에서 같거나 오히려 낮은 수준이라 실제 프로그램에서 별로 사용하지 않습니다.