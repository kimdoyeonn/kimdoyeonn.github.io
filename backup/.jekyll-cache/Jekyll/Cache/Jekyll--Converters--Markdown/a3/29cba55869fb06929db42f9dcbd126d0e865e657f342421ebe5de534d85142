I"<p>참고: doit 자료구조와 함께 배우는 알고리즘 입문</p>

<h4 id="kmp법-알아보기">KMP법 알아보기</h4>

<p>브루트 포스법은 일치하지 않는 문자를 만나면 이전 단계에서 검사했던 결과를 버리고 패턴의 첫 문자부터 다시 검사를 수행합니다. 하지만 KMP법은 검사했던 결과를 버리지 않고 효율적으로 활용하는 알고리즘입니다.</p>

<blockquote>
  <p>KMP법은 Knuth-Morris-Pratt법의 줄임말로 이 알고리즘을 고안한 세 명의 이름에서 따온 용어입니다.</p>
</blockquote>

<p>KMP법은 텍스트와 패턴 안에서 겹치는 문자열을 찾아내 검사를 다시 시작할 위치를 구하여 패터느이 이동을 되도록이면 크게 하는 알고리즘이니다. 그런데 몇 번째 문자부터 검사를 다시 시작할지 패턴을 이동할 때마다 계산한다면 좋은 효율을 기대할 수 없습니다. 그래서 KMP법은 ‘몇 번째 문자부터 다시 검색할지’값을 표로 만들어서 문제를 해결합니다.</p>

<h4 id="kmp법에서-사용하는-표-만들기">KMP법에서 사용하는 표 만들기</h4>

<p>표를 작성할 때는 패턴에서 겹치는 문자열을 찾습니다. 이 과정에서도 KMP법과 같은 방법을 적용합니다. 패턴의 첫 문자가 일치하지 않으면 패턴을 오른쪽으로 1칸 밀어 첫 문자부터 검사해야 하므로 2번째 문자 이후 부분을 생각합니다. 또 패턴과 텍스트를 서로 겹치도록 맞추는 것이 아니라 패턴끼리(즉, 패턴과 패턴을) 서로 겹치도록 맞추고 검사를 시작할 곳을 계산합니다.</p>

<blockquote>
  <p>p312 건너뛰기 표 이해안됨</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">kmp_match</span><span class="p">(</span><span class="n">txt</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pat</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">"""KMP법으로 문자열 검색"""</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="mi">1</span>                          <span class="c1"># txt를 따라가는 커서
</span>    <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span>                          <span class="c1"># pat를 따라가는 커서
</span>    <span class="n">skip</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>     <span class="c1"># 건너뛰기 표
</span>
    <span class="c1"># 건너뛰기 표 만들기
</span>    <span class="n">skip</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">pt</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pat</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">==</span> <span class="n">pat</span><span class="p">[</span><span class="n">pp</span><span class="p">]:</span>
            <span class="n">pt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">pp</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">skip</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span>
        <span class="k">elif</span> <span class="n">pp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">skip</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="n">skip</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span>

    <span class="c1"># 문자열 검색하기
</span>    <span class="n">pt</span> <span class="o">=</span> <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">pt</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pp</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">txt</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">==</span> <span class="n">pat</span><span class="p">[</span><span class="n">pp</span><span class="p">]:</span>
            <span class="n">pt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">pp</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">pp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="n">skip</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">pp</span> <span class="k">if</span> <span class="n">pp</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>KMP법에서 텍스트를 스캔하는 커서 pt는 앞으로 나아갈 뿐 뒤로 되돌아오지 않습니다. 이것은 브루트 포스법에는 없는 특징입니다. 그러나 이 알고리즘은 복잡할 뿐 보이어무어법보다 성능 면에서 같거나 오히려 낮은 수준이라 실제 프로그램에서 별로 사용하지 않습니다.</p>
:ET