---
title: "[algorithm]1463 1로 만들기"
excerpt: ""
category:
  - algorithm
tags: [python, baekjoon, algorithm]
---

참고: [백준](https://www.acmicpc.net/problem/1463)

| 시간 제한 | 메모리 제한 | 제출   | 정답  | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :----- | :---- | :-------- | :-------- |
| 0.5 초    | 128 MB      | 130500 | 40263 | 25595     | 31.991%   |

## 문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

## 입력

첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

## 출력

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

## 예제 입력 1 복사

```
2
```

## 예제 출력 1 복사

```
1
```

## 예제 입력 2 복사

```
10
```

## 예제 출력 2 복사

```
3
```



#### 내 풀이

```python
n = int(input())

dp = [0 for _ in range(n+1)]
cnt = 0

for i in range(2, n+1):
    dp[i] = dp[i-1] + 1
    if i % 2 == 0 and dp[i] > dp[i//2]+1:
        dp[i] = dp[i//2] + 1
    if i % 3 == 0 and dp[i] > dp[i//3]+1:
        dp[i] = dp[i//3] + 1
print(dp[n])
```

주어진 숫자가 n이라고 하면 dp[n]은 n이 1이 되는데 필요한 최소 횟수이다.

n을 1로 만드는데 3가지 경우를 조합해서 사용하면 되는데 각 인접한 항들이 일정한 관계를 맺고 있기 때문에 점화식을 잘 세워서 풀면 된다.

문제에서 주어진 세 조건에 대해 점화식 풀어서 나타내면

- n이 2로 나누어 떨어질 경우 2로 나눔

  점화식을 사용할 했으므로 dp[n//2]에는 그에 해당하는 최적값이 들어가게 되어있다. 이걸 이용하면 dp[n]은 dp[n//2]에서 연산을 한번 더 사용한 경우이기때문에 dp[n]은 dp[n//2] + 1이 성립한다.

  `dp[n] = dp[n//2]+1`

- n이 3으로 나누어 떨어질 경우 3으로 나눔

  2로 나누었을 때와 같은 방법으로 생각해보면 `dp[n] = dp[n//3]+1`

- n에서 1을 뻄

  `dp[n] = dp[n-1] + 1`

  dp[n-1]에 연산 한번을 더 사용하면 dp[n]이 됨



여기서 세 방법을 조합해서 답을 내면 되는데 문제에서는 최솟값을 구하라고 했기 때문에 위의 점화식을 정리해보면

`dp[n] = min(dp[n//2], dp[n//3], dp[n-1]) + 1`

로 만들 수 있다.

이제 작은 수부터 차례대로 최솟값으로 dp 리스트를 채우면서 연산하면 입력받은 수를 만드는데 필요한 연산 횟수의 최솟값을 구할 수 있다.