---
title: "[컴퓨터구조]19_Pipeline CPU의 성능 분석"
excerpt: ""
category:
  - 컴퓨터 공학
tags: [컴퓨터구조, 컴퓨터 공학]
---

- Pipeline CPU의 성능 분석
  - 파이프라인 분기 예측
  - RISC Processor
  - 파이프라인 CPU 성능 분석



**명령어 파이프라인이 정상적인 동작에서 벗어나게 되는 요인**

- 자원 충돌(Resource conflict)

  두 세그먼트가 동시에 메모리에 접근하려고 하는데서 기인하는데, 명령어 메모리와 데이터 메모리를 분리함으로써 대부분 해결할 수 있다.

- 데이터 의존성(data dependency)

  어떤 명령어가 이전 명령어의 결과에 의존하여 수행되는데, 그 값이 아직 준비되지 읂은 경우 발생한다. 

- 분기 곤란(branch difficulty)

  분기 명령어같이 PC의 값을 변경시키려는 명령어에 의해 발생한다



### 데이터 의존성

데이터나 주소의 충돌은 명령어 파이프라이늬 성능을 저하시키는 요인이 된다.

**데이터 의존성**

- 아직 준비되지 않은 데이터를 기다리는 경우에 발생한다고 할 수 있다.
- ex. FO에 의해 피연산자를 fetch하려고 하는 경우 아직 EX세그먼트에 의해 데이터가 만들어지지 않은 경우

**주소 의존성**

- 마이크로 연산 시 레지스터 간접모드를 사용하는 명령어는 이전 명령어가 주소값을 메모리로부터 로드하는 명령이라면 곧바로 피 연산자를 fetch하지 못하고 기다리게 된다.



**데이터 의존성 해결 방법**

- hardware interlock / 하드웨어 인터락

  어떤 명령어의 피연산자가 파이프라인에 앞서간 명령어의 목적지와 일치하는지 검사한다. 이러한 상황이 감지되면 피연산자가 준비되지 않은 명령어는 충돌을 피할 수 있을 만큼 충분한 클럭 사이클을 두어 지연시킨다.

- operand forwarding / 오퍼랜드 포워딩

  충돌을 감지하는 경우 특별한 통로를 통해 직접 파이프라인 세그먼트를 전달하는 경우

  있을 수 있는 모든 충돌을 색인으로 체크해놓고 감지될 경우 정해진 경로로 처리한다.



**분기 명령어의 처리**

조건분기 또는 무조건분기 등은 처리여하에 따라 파이프라인의 정상적인 프로그램 순서를 바꾸어버리기 때문에 파이프라인 시스템을 채택하고 있는 컴퓨터의 성능을 저하시키는 주요인으로 간주되고 있다.

순차적으로 처리될 명령어를 분기의 목표가 되는 명령어와 함께 저장하는 방법을 사용한다.

- 분기 목표 버퍼 / branch target buffer, BTB 의 사용

  fetch 세그먼트에 속해있는 associate memory

  (associate memory : 주소가 아닌 내용에 의해 검색이 가능한 기억장치)

  이전에 실행된 분기 명령어의 분기 목표 명령어를 저장하여 활용한다. (loop buffer - 일종의 레지스터)

- 분기 예측(branch prediction)

  실제 다양한 프로그램의 실행 결과를 분석한 결과, 참조의 시간적 지역성과 유사하게 일부 명령어들은 반복 수행되며 반복 실행 시에는 규칙성을 갖는다.

  이러한 예측 기법을 이용하여 분기 및 적재 명령어가 참조하는 오퍼랜드도 반복 참조 시 규칙성을 갖고 있으며 이를 이용할 경우 fetch 과정에서 신속하게 오퍼랜드의 제공 및 fetch가 수월해 질 수 있다. 다만 예측 실패시 패널티(시간지연)이 있을 수 있다.



### RISC Processor

**RISC 프로세서의 설계 목표**

실행 명령어 수는 증가하더라도 작업 처리 시간은 감소시킬 수 있다.

명령어당 실행 클록수(CPI)와 클록 주기를 파이프라인 구조를 이용하여 감소시킬 수 있다.



**RISC 프로세서의 구조적 특징**

- 명령어의 1 사이클 실행을 위한 파이프라인 구조, 메모리 참조를 위한 온칩캐쉬(CPU 내 메모리 구현, 명령어 캐쉬, 자료 캐쉬로 구성)
- 간단한 명령 코드와 주소 지정 모드 및 하드웨어적 제어장치
- 신속한 오퍼랜드 참소/문맥 전환을 위한 레지스터 집합(중첩된 레지스터 윈도우)
- 실수 연산의 별도 처리를 위한 코프로세서(co-processor)



**RISC 파이프라인**

- 명령어 사이클은 세 개의 부연산으로 나뉘어 다음과 같은 세 세그먼트로 구성된다.
- 딜레이 시간을 프로그램적으로 주는 것이 아니라 컴파일러로 준다.

![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/d152029a-074d-420f-bf80-7c0273745388/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210529%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210529T132525Z&X-Amz-Expires=86400&X-Amz-Signature=c6387cdb8733c88bdcaddc7e136adcd64e3f4f68db89c87f4828ec55a5719504&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)



### 파이프라인 CPU 성능 향상

이론적으로는 명령어 세그먼트의 횟수가 많아질수록 파이프라인의 최대 속도가 증가하는 것으로 분석되었으나, 이를 구현하기 위해서는 까다로운 조건이 필요하다.

- 모든 명령어는 동일한 처리과정(세그먼트의 적용)으로 처리되어야한다.
- 파이프라인을 구성하는 각 단계의 처리 시간이 일정해야 한다.
- 모든 명령어는 작성된 순서에 따라 순차적으로 실행되어야 한다. (분기명령, 함수호출, 반환명령 등에 의해 순차성이 깨지지 않아야함)
- 사용 명령어들 사이에는 상호 의존성이 없어야한다.
- 명령어들 처리 시 공유 자원의 충돌이 없어야한다.
  이 부분은 명령어를 저장하는 공간과 자료를 저장하는 공간을 분리함으로써 해결할 수 있다.
